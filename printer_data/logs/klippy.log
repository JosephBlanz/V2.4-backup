Starting Klippy...
Args: ['/home/pi/klipper/klippy/klippy.py', '/home/pi/printer_data/config/printer.cfg', '-I', '/home/pi/printer_data/comms/klippy.serial', '-l', '/home/pi/printer_data/logs/klippy.log', '-a', '/home/pi/printer_data/comms/klippy.sock']
Git version: 'v0.12.0-98-g5e433fff-dirty'
Untracked files: klippy/extras/gcode_shell_command.py
Branch: master
Remote: origin
Tracked URL: https://github.com/Klipper3d/klipper
CPU: 4 core ?
Python: '3.9.2 (default, Feb 28 2021, 17:03:44) \n[GCC 10.2.1 20210110]'
Start printer at Fri Jan 26 22:42:22 2024 (1706308942.8 1358.5)
===== Config file =====
[gcode_shell_command hello_world]
command = echo hello world
timeout = 2.
verbose = True

[gcode_macro HELLO_WORLD]
gcode = 
	RUN_SHELL_COMMAND CMD=hello_world

[virtual_sdcard]
path = ~/printer_data/gcodes
on_error_gcode = CANCEL_PRINT

[pause_resume]

[display_status]

[respond]

[gcode_macro CANCEL_PRINT]
description = Cancel the actual running print
rename_existing = BASE_CANCEL_PRINT
gcode = 
	SET_IDLE_TIMEOUT TIMEOUT={printer.configfile.settings.idle_timeout.timeout}
	CLEAR_PAUSE
	SDCARD_RESET_FILE
	PRINT_END
	BASE_CANCEL_PRINT

[gcode_macro PAUSE]
description = Pause the actual running print
rename_existing = BASE_PAUSE
variable_restore_idle_timeout = 0
gcode = 
	
	{% set z = params.Z|default(10)|int %}
	
	{% if printer['pause_resume'].is_paused|int == 0 %}
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=zhop VALUE={z}
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=etemp VALUE={printer['extruder'].target}
	
	SET_FILAMENT_SENSOR SENSOR=filament_sensor ENABLE=0
	SAVE_GCODE_STATE NAME=PAUSE
	BASE_PAUSE
	{% if (printer.gcode_move.position.z + z) < printer.toolhead.axis_maximum.z %}
	G91
	G1 Z{z} F900
	{% else %}
	{ action_respond_info("Pause zhop exceeds maximum Z height.") }
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=zhop VALUE=0
	{% endif %}
	G90
	G1 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_minimum.y+5} F6000
	SAVE_GCODE_STATE NAME=PAUSEPARK
	M104 S0
	SET_IDLE_TIMEOUT TIMEOUT=43200
	{% endif %}

[gcode_macro RESUME]
description = Resume the actual running print
rename_existing = BASE_RESUME
variable_last_extruder_temp = {'restore': False, 'temp': 0}
gcode = 
	
	{% set e = params.E|default(2.5)|int %}
	
	{% if printer['pause_resume'].is_paused|int == 1 %}
	SET_FILAMENT_SENSOR SENSOR=filament_sensor ENABLE=1
	
	SET_IDLE_TIMEOUT TIMEOUT={printer.configfile.settings.idle_timeout.timeout}
	{% if etemp > 0 %}
	M109 S{etemp|int}
	{% endif %}
	RESTORE_GCODE_STATE NAME=PAUSEPARK MOVE=1 MOVE_SPEED=100
	G91
	M83
	{% if printer[printer.toolhead.extruder].temperature >= printer.configfile.settings.extruder.min_extrude_temp %}
	G1 Z{zhop * -1} E{e} F900
	{% else %}
	G1 Z{zhop * -1} F900
	{% endif %}
	RESTORE_GCODE_STATE NAME=PAUSE MOVE=1 MOVE_SPEED=60
	BASE_RESUME
	{% endif %}
variable_zhop = 0
variable_etemp = 0

[gcode_macro SET_PAUSE_NEXT_LAYER]
description = Enable a pause if the next layer is reached
gcode = 
	{% set pause_next_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_next_layer %}
	{% set ENABLE = params.ENABLE|default(1)|int != 0 %}
	{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ 'enable': ENABLE, 'call': MACRO }}"

[gcode_macro SET_PAUSE_AT_LAYER]
description = Enable/disable a pause if a given layer number is reached
gcode = 
	{% set pause_at_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_at_layer %}
	{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined
	else params.LAYER is defined %}
	{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}
	{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ 'enable': ENABLE, 'layer': LAYER, 'call': MACRO }}"

[gcode_macro SET_PRINT_STATS_INFO]
rename_existing = SET_PRINT_STATS_INFO_BASE
description = Overwrite, to get pause_next_layer and pause_at_layer feature
variable_pause_next_layer = { 'enable': False, 'call': "PAUSE" }
variable_pause_at_layer = { 'enable': False, 'layer': 0, 'call': "PAUSE" }
gcode = 
	{% if pause_next_layer.enable %}
	RESPOND TYPE=echo MSG='{"%s, forced by pause_next_layer" % pause_next_layer.call}'
	{pause_next_layer.call}
	SET_PAUSE_NEXT_LAYER ENABLE=0
	{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}
	RESPOND TYPE=echo MSG='{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}'
	{pause_at_layer.call}
	SET_PAUSE_AT_LAYER ENABLE=0
	{% endif %}
	SET_PRINT_STATS_INFO_BASE {rawparams}

[gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL]
description = Helper: park toolhead used in PAUSE and CANCEL_PRINT
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
	{% set use_custom     = client.use_custom_pos|default(false)|lower == 'true' %}
	{% set custom_park_x  = client.custom_park_x|default(0.0) %}
	{% set custom_park_y  = client.custom_park_y|default(0.0) %}
	{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}
	{% set sp_hop         = client.speed_hop|default(15) * 60 %}
	{% set sp_move        = client.speed_move|default(velocity) * 60 %}
	
	{% set origin    = printer.gcode_move.homing_origin %}
	{% set act       = printer.gcode_move.gcode_position %}
	{% set max       = printer.toolhead.axis_maximum %}
	{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}
	{% set round_bed = True if printer.configfile.settings.printer.kinematics is in ['delta','polar','rotary_delta','winch']
	else False %}
	
	{% set z_min = params.Z_MIN|default(0)|float %}
	{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}
	{% set x_park = params.X       if params.X is defined
	else custom_park_x  if use_custom
	else 0.0            if round_bed
	else (max.x - 5.0) %}
	{% set y_park = params.Y       if params.Y is defined
	else custom_park_y  if use_custom
	else (max.y - 5.0)  if round_bed and z_park < cone
	else 0.0            if round_bed
	else (max.y - 5.0) %}
	
	_CLIENT_RETRACT
	{% if "xyz" in printer.toolhead.homed_axes %}
	G90
	G1 Z{z_park} F{sp_hop}
	G1 X{x_park} Y{y_park} F{sp_move}
	{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}
	{% else %}
	RESPOND TYPE=echo MSG='Printer not homed'
	{% endif %}

[gcode_macro _CLIENT_EXTRUDE]
description = Extrudes, if the extruder is hot enough
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}
	{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}
	{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}
	{% set absolute_extrude = printer.gcode_move.absolute_extrude %}
	
	{% if printer.toolhead.extruder != '' %}
	{% if printer[printer.toolhead.extruder].can_extrude %}
	{% if use_fw_retract %}
	{% if length < 0 %}
	G10
	{% else %}
	G11
	{% endif %}
	{% else %}
	M83
	G1 E{length} F{(speed|float|abs) * 60}
	{% if absolute_extrude %}
	M82
	{% endif %}
	{% endif %}
	{% else %}
	RESPOND TYPE=echo MSG='Extruder not hot enough'
	{% endif %}
	{% endif %}

[gcode_macro _CLIENT_RETRACT]
description = Retracts, if the extruder is hot enough
gcode = 
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}
	{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}
	
	_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}

[adxl345]
cs_pin = SB2240: PB12
spi_software_sclk_pin = SB2240: PB10
spi_software_mosi_pin = SB2240: PB11
spi_software_miso_pin = SB2240: PB2
axes_map = z,-y,x

[resonance_tester]
probe_points = 100, 100, 20
accel_chip = adxl345

[bed_mesh]
speed = 300
horizontal_move_z = 1
mesh_min = 40, 40
mesh_max = 310,310
zero_reference_position = 175,175
fade_start = 0.6
fade_end = 10.0
probe_count = 5,5
algorithm = bicubic

[fan]
pin = SB2240: PA1
kick_start_time = 0.5
off_below = 0.09

[heater_fan hotend_fan]
pin = SB2240: PA0
max_power = 1.0
kick_start_time = 0.5
heater = extruder
heater_temp = 50.0

[board_pins]
aliases = 
	
	EXP1_1=PE9, EXP1_2=PE10,
	EXP1_3=PE11, EXP1_4=PE12,
	EXP1_5=PE13, EXP1_6=PE14,
	EXP1_7=PE15, EXP1_8=PB10,
	EXP1_9=<GND>, EXP1_10=<5V>,
	
	
	EXP2_1=PB14, EXP2_2=PB13,
	EXP2_3=PF7, EXP2_4=PB12,
	EXP2_5=PE7, EXP2_6=PB11,
	EXP2_7=PE8, EXP2_8=<RST>,
	EXP2_9=<GND>, EXP2_10=PC5

[display]
lcd_type = uc1701
cs_pin = EXP1_3
a0_pin = EXP1_4
rst_pin = EXP1_5
encoder_pins = ^EXP2_5, ^EXP2_3
click_pin = ^!EXP1_2
contrast = 63
spi_software_miso_pin = EXP2_1
spi_software_mosi_pin = EXP2_6
spi_software_sclk_pin = EXP2_2

[neopixel btt_mini12864]
pin = EXP1_6
chain_count = 3
initial_red = 0.1
initial_green = 0.5
initial_blue = 0.0
color_order = RGB

[delayed_gcode setdisplayneopixel]
initial_duration = 1
gcode = 
	SET_LED LED=btt_mini12864 RED=1 GREEN=1 BLUE=1 INDEX=1 TRANSMIT=0
	SET_LED LED=btt_mini12864 RED=1 GREEN=0 BLUE=0 INDEX=2 TRANSMIT=0
	SET_LED LED=btt_mini12864 RED=1 GREEN=0 BLUE=0 INDEX=3

[mcu]
serial = /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00
restart_method = command

[mcu SB2240]
canbus_uuid = 1d98beae65e3

[quad_gantry_level]
gantry_corners = 
	-60,-10
	410,420
points = 
	50,25
	50,275
	300,275
	300,25
speed = 400
horizontal_move_z = 5
retries = 5
retry_tolerance = 0.0075
max_adjust = 10

[safe_z_home]
home_xy_position = 175,175
speed = 150
z_hop = 10

[stepper_x]
step_pin = PE2
dir_pin = PB4
enable_pin = !PC11
microsteps = 128
rotation_distance = 40
full_steps_per_rotation = 200
endstop_pin = ^PF3
position_min = 0
position_endstop = 350
position_max = 350
homing_speed = 100
homing_retract_dist = 5
homing_positive_dir = true

[tmc2209 stepper_x]
uart_pin = PC10
interpolate = True
run_current = 0.8
stealthchop_threshold = 0

[stepper_y]
step_pin = PF12
dir_pin = PF11
enable_pin = !PB3
microsteps = 128
rotation_distance = 40
endstop_pin = ^PF4
full_steps_per_rotation = 200
position_min = 0
position_endstop = 350
position_max = 350
homing_speed = 100
homing_retract_dist = 5
homing_positive_dir = true

[tmc2209 stepper_y]
uart_pin = PF13
interpolate = True
run_current = 0.8
stealthchop_threshold = 0

[stepper_z]
step_pin = PD7
dir_pin = PD6
enable_pin = !PF10
rotation_distance = 40
gear_ratio = 80:16
microsteps = 256
endstop_pin = probe:z_virtual_endstop
position_max = 340
position_min = -5
homing_speed = 8
second_homing_speed = 3
homing_retract_dist = 3

[tmc2209 stepper_z]
uart_pin = PF9
interpolate = true
run_current = 0.6
stealthchop_threshold = 999999

[stepper_z1]
step_pin = PC9
dir_pin = !PC8
enable_pin = !PD1
rotation_distance = 40
gear_ratio = 80:16
microsteps = 256

[tmc2209 stepper_z1]
uart_pin = PD0
interpolate = true
run_current = 0.6
stealthchop_threshold = 999999

[stepper_z2]
step_pin = PA10
dir_pin = PD15
enable_pin = !PA15
rotation_distance = 40
gear_ratio = 80:16
microsteps = 256

[tmc2209 stepper_z2]
uart_pin = PF8
interpolate = true
run_current = 0.6
stealthchop_threshold = 999999

[stepper_z3]
step_pin = PD12
dir_pin = !PD11
enable_pin = !PD14
rotation_distance = 40
gear_ratio = 80:16
microsteps = 256

[tmc2209 stepper_z3]
uart_pin = PD13
interpolate = true
run_current = 0.6
stealthchop_threshold = 999999

[temperature_sensor M8P]
sensor_type = temperature_mcu
min_temp = 0
max_temp = 100

[temperature_sensor CM4]
sensor_type = temperature_host
min_temp = 10
max_temp = 100

[temperature_sensor SB2240]
sensor_type = temperature_mcu
sensor_mcu = SB2240
min_temp = 0
max_temp = 100

[gcode_macro update_git]
gcode = 
	RUN_SHELL_COMMAND CMD=update_git_script

[gcode_shell_command update_git_script]
command = bash /home/pi/klipper-backup/script.sh
timeout = 90.0
verbose = True

[gcode_macro DUMP_VARIABLES]
gcode = 
	{% set filter_name = params.NAME|default('')|string|lower %}
	{% set filter_value = params.VALUE|default('')|string|lower %}
	{% set show_cfg = params.SHOW_CFG|default(0)|int %}
	
	{% set out = [] %}
	
	{% for key1 in printer %}
	{% for key2 in printer[key1] %}
	{% if (show_cfg or not (key1|lower == 'configfile' and key2|lower in ['config', 'settings'])) and (filter_name in key1|lower or filter_name in key2|lower) and filter_value in printer[key1][key2]|string|lower %}
	{% set dummy = out.append("printer['%s'].%s = %s" % (key1, key2, printer[key1][key2])) %}
	{% endif %}
	{% else %}
	{% if filter_name in key1|lower and filter_value in printer[key1]|string|lower %}
	{% set dummy = out.append("printer['%s'] = %s" % (key1, printer[key1])) %}
	{% endif %}
	{% endfor %}
	{% endfor %}
	
	{action_respond_info(out|join("\n"))}

[gcode_macro G32]
gcode = 
	BED_MESH_CLEAR
	G28
	QUAD_GANTRY_LEVEL
	G28

[gcode_macro GET_VARIABLE]
gcode = 
	{% set names = (params.NAME).split('.')|list %}
	{% set join = (params.JOIN)|default(1)|int %}
	
	{% set _dummy0 = namespace( break = 0 ) %}
	{% set _dummy1 = namespace( out = printer[names|first] ) %}
	
	{% for name in names if _dummy0.break == 0 %}
	{% if loop.index > 1 %}
	{% if name in _dummy1.out %}
	{% set _dummy1.out = _dummy1.out[name] %}
	{% elif name[0] in '0123456789' and _dummy1.out is iterable and _dummy1.out is not string and _dummy1.out is not mapping and _dummy1.out|length > name[0]|int %}
	{% set _dummy1.out = _dummy1.out[name|int] %}
	{% else %}
	{% set _dummy0.break = loop.index0 %}
	{% endif %}
	{% endif %}
	{% endfor %}
	
	{% if _dummy1.out is boolean %}
	{ action_respond_info('Type: boolean') }
	{% elif _dummy1.out is float %}
	{ action_respond_info('Type: float') }
	{% elif _dummy1.out is integer %}
	{ action_respond_info('Type: integer') }
	{% elif _dummy1.out is mapping %}
	{ action_respond_info('Type: mapping') }
	{% elif _dummy1.out is string %}
	{ action_respond_info('Type: string') }
	{% elif _dummy1.out is iterable %}
	{ action_respond_info('Type: iterable') }
	{% elif _dummy1.out is none %}
	{ action_respond_info('Type: none') }
	{% elif _dummy1.out is undefined %}
	{ action_respond_info('Type: undefined') }
	{% elif _dummy1.out is callable %}
	{ action_respond_info('Type: callable') }
	{% else %}
	{ action_respond_info('Type: unknown') }
	{% endif %}
	
	{% if join and _dummy1.out is iterable and _dummy1.out is not string and _dummy1.out is not mapping %}
	{ action_respond_info('%s' % _dummy1.out|join("\n")) }
	{% else %}
	{ action_respond_info('%s' % _dummy1.out) }
	{% endif %}
	
	{% if _dummy0.break != 0 %}
	{ action_respond_info('"printer.%s" does not contain "%s"!' % (names[0:_dummy0.break]|join('.'), names[_dummy0.break])) }
	{% endif %}

[neopixel sb_leds]
pin = SB2240:PD3
chain_count = 3
color_order = GRBW
initial_red = 1.0
initial_green = 0.0
initial_blue = 1.0
initial_white = 0.0

[gcode_macro _sb_vars]
variable_colors = {
	'logo': {
	'busy': {'r': 0.4, 'g': 0.0, 'b': 0.0, 'w': 0.0},
	'cleaning': {'r': 0.0, 'g': 0.02, 'b': 0.5, 'w': 0.0},
	'calibrating_z': {'r': 0.8, 'g': 0., 'b': 0.35, 'w': 0.0},
	'heating': {'r': 0.3, 'g': 0.18, 'b': 0.0, 'w': 0.0},
	'homing': {'r': 0.0, 'g': 0.6, 'b': 0.2, 'w': 0.0},
	'leveling': {'r': 0.5, 'g': 0.1, 'b': 0.4, 'w': 0.0},
	'meshing': {'r': 0.2, 'g': 1.0, 'b': 0.0, 'w': 0.0},
	'off': {'r': 0.0, 'g': 0.0, 'b': 0.0, 'w': 0.0},
	'printing': {'r': 1.0, 'g': 0.0, 'b': 0.0, 'w': 0.0},
	'standby': {'r': 0.01, 'g': 0.01, 'b': 0.01, 'w': 0.1},
	},
	'nozzle': {
	'heating': {'r': 0.8, 'g': 0.35, 'b': 0.0, 'w':0.0},
	'off': {'r': 0.0, 'g': 0.0, 'b': 0.0, 'w': 0.0},
	'on': {'r': 0.8, 'g': 0.8, 'b': 0.8, 'w':1.0},
	'standby': {'r': 0.6, 'g': 0.0, 'b': 0.0, 'w':0.0},
	},
	'thermal': {
	'hot': {'r': 1.0, 'g': 0.0, 'b': 0.0, 'w': 0.0},
	'cold': {'r': 0.3, 'g': 0.0, 'b': 0.3, 'w': 0.0}
	}
	}
variable_logo_led_name = "sb_leds"
variable_logo_idx = "1"
variable_nozzle_led_name = "sb_leds"
variable_nozzle_idx = "2,3"
gcode = 

[gcode_macro _set_sb_leds]
gcode = 
	{% set red = params.RED|default(0)|float %}
	{% set green = params.GREEN|default(0)|float %}
	{% set blue = params.BLUE|default(0)|float %}
	{% set white = params.WHITE|default(0)|float %}
	{% set led = params.LED|string %}
	{% set idx = (params.IDX|string).split(',') %}
	{% set transmit_last = params.TRANSMIT|default(1) %}
	
	{% for led_index in idx %}
	{% set transmit=transmit_last if loop.last else 0 %}
	set_led led={led} red={red} green={green} blue={blue} white={white} index={led_index} transmit={transmit}
	{% endfor %}

[gcode_macro _set_sb_leds_by_name]
gcode = 
	{% set leds_name = params.LEDS %}
	{% set color_name = params.COLOR %}
	{% set color = printer["gcode_macro _sb_vars"].colors[leds_name][color_name] %}
	{% set led = printer["gcode_macro _sb_vars"][leds_name + "_led_name"] %}
	{% set idx = printer["gcode_macro _sb_vars"][leds_name + "_idx"] %}
	{% set transmit = params.TRANSMIT|default(1) %}
	
	_set_sb_leds led={led} red={color.r} green={color.g} blue={color.b} white={color.w} idx="{idx}" transmit={transmit}

[gcode_macro _set_logo_leds]
gcode = 
	{% set red = params.RED|default(0)|float %}
	{% set green = params.GREEN|default(0)|float %}
	{% set blue = params.BLUE|default(0)|float %}
	{% set white = params.WHITE|default(0)|float %}
	{% set led = printer["gcode_macro _sb_vars"].logo_led_name %}
	{% set idx = printer["gcode_macro _sb_vars"].logo_idx %}
	{% set transmit=params.TRANSMIT|default(1) %}
	
	_set_sb_leds led={led} red={red} green={green} blue={blue} white={white} idx="{idx}" transmit={transmit}

[gcode_macro _set_nozzle_leds]
gcode = 
	{% set red = params.RED|default(0)|float %}
	{% set green = params.GREEN|default(0)|float %}
	{% set blue = params.BLUE|default(0)|float %}
	{% set white = params.WHITE|default(0)|float %}
	{% set led = printer["gcode_macro _sb_vars"].nozzle_led_name %}
	{% set idx = printer["gcode_macro _sb_vars"].nozzle_idx %}
	{% set transmit=params.TRANSMIT|default(1) %}
	
	_set_sb_leds led={led} red={red} green={green} blue={blue} white={white} idx="{idx}" transmit={transmit}

[gcode_macro set_logo_leds_off]
gcode = 
	{% set transmit=params.TRANSMIT|default(1) %}
	_set_logo_leds red=0 blue=0 green=0 white=0 transmit={transmit}

[gcode_macro set_nozzle_leds_on]
gcode = 
	{% set transmit=params.TRANSMIT|default(1) %}
	_set_sb_leds_by_name leds="nozzle" color="on" transmit={transmit}

[gcode_macro set_nozzle_leds_off]
gcode = 
	{% set transmit=params.TRANSMIT|default(1) %}
	_set_sb_leds_by_name leds="nozzle" color="off" transmit={transmit}

[gcode_macro status_off]
gcode = 
	set_logo_leds_off transmit=0
	set_nozzle_leds_off

[gcode_macro status_ready]
gcode = 
	_set_sb_leds_by_name leds="logo" color="standby" transmit=0
	_set_sb_leds_by_name leds="nozzle" color="standby" transmit=1

[gcode_macro status_busy]
gcode = 
	_set_sb_leds_by_name leds="logo" color="busy" transmit=0
	set_nozzle_leds_on

[gcode_macro status_heating]
gcode = 
	_set_sb_leds_by_name leds="logo" color="heating" transmit=0
	_set_sb_leds_by_name leds="nozzle" color="heating" transmit=1

[gcode_macro status_leveling]
gcode = 
	_set_sb_leds_by_name leds="logo" color="leveling" transmit=0
	set_nozzle_leds_on

[gcode_macro status_homing]
gcode = 
	_set_sb_leds_by_name leds="logo" color="homing" transmit=0
	set_nozzle_leds_on

[gcode_macro status_cleaning]
gcode = 
	_set_sb_leds_by_name leds="logo" color="cleaning" transmit=0
	set_nozzle_leds_on

[gcode_macro status_meshing]
gcode = 
	_set_sb_leds_by_name leds="logo" color="meshing" transmit=0
	set_nozzle_leds_on

[gcode_macro status_calibrating_z]
gcode = 
	_set_sb_leds_by_name leds="logo" color="calibrating_z" transmit=0
	set_nozzle_leds_on

[gcode_macro status_printing]
gcode = 
	_set_sb_leds_by_name leds="logo" color="printing" transmit=0
	set_nozzle_leds_on

[gcode_macro NOZZLE_CLEAN]
variable_start_x = 175
variable_start_y = 347
variable_start_z = 9.68
variable_wipe_dist_y = 3
variable_wipe_qty = 5
variable_wipe_spd = 50
variable_raise_distance = 18
gcode = 
	
	{% set ACTUAL_TEMP = printer.extruder.temperature %}
	{% set TARGET_TEMP = printer.extruder.target %}
	{% set WIPE_TEMP = 200 %}
	{% set MIN_TEMP = 170 %}
	
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	
	G1 X{start_x - 30} Y{start_y} F6000
	
	{% if ACTUAL_TEMP < WIPE_TEMP %}
	M104 S{ WIPE_TEMP }
	G4 2500
	{% endif %}
	
	G90
	G1 Z{start_z} F1500
	G91
	G1 X60 F6000
	G1 X-60 F6000
	G1 X60 F6000
	G1 X-60 F6000
	G1 X60 F6000
	G1 X-60 F6000
	
	G90
	
	G1 Z{start_z} F1500
	G1 X{start_x} Y{start_y} F6000
	
	
	G91
	{% for wipes in range(1, (wipe_qty + 1)) %}
	
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	
	{% endfor %}
	
	G90
	G1 X{start_x - 60} Y{start_y} F6000
	G1 YY{start_y} F6000

[gcode_macro OFF]
gcode = 
	M84
	TURN_OFF_HEATERS
	M107

[gcode_macro PARKFRONT]
gcode = 
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	SAVE_GCODE_STATE NAME=PARKFRONT
	G90
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_minimum.y+5} Z{printer.toolhead.axis_maximum.z/2} F12000
	RESTORE_GCODE_STATE NAME=PARKFRONT

[gcode_macro PARKFRONTLOW]
gcode = 
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	SAVE_GCODE_STATE NAME=PARKFRONT
	G90
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_minimum.y+5} Z20 F12000
	RESTORE_GCODE_STATE NAME=PARKFRONT

[gcode_macro PARKREAR]
gcode = 
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	SAVE_GCODE_STATE NAME=PARKREAR
	G90
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_maximum.y-10} Z{printer.toolhead.axis_maximum.z/2} F12000
	RESTORE_GCODE_STATE NAME=PARKREAR

[gcode_macro PARKCENTER]
gcode = 
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	SAVE_GCODE_STATE NAME=PARKCENTER
	G90
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_maximum.y/2} Z{printer.toolhead.axis_maximum.z/2} F12000
	RESTORE_GCODE_STATE NAME=PARKCENTER

[gcode_macro PARKBED]
gcode = 
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	SAVE_GCODE_STATE NAME=PARKBED
	G90
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_maximum.y/2} Z15 F12000
	RESTORE_GCODE_STATE NAME=PARKBED

[gcode_macro PRINT_END]
gcode = 
	M400
	G92 E0
	G1 E-10.0 F3600
	G91
	G0 Z1.00 X20.0 Y20.0 F20000
	TURN_OFF_HEATERS
	M107
	G1 Z2 F3000
	G90
	G0  X175 Y350 F3600
	BED_MESH_CLEAR

[gcode_macro PRINT_START]
gcode = 
	
	{% set target_bed = params.BED|int %}
	{% set target_extruder = params.EXTRUDER|int %}
	
	{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}
	{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}
	
	
	STATUS_HOMING
	M109 S150
	M190 S{target_bed}
	G28
	G90
	
	NOZZLE_CLEAN
	
	
	BED_MESH_CLEAR
	
	
	{% if params.BED|int > 90 %}
	SET_DISPLAY_TEXT MSG="Bed: {target_bed}c"
	STATUS_HEATING
	M106 S255
	
	
	
	
	G1 X{x_wait} Y{y_wait} Z15 F9000
	M190 S{target_bed}
	
	
	
	
	{% else %}
	SET_DISPLAY_TEXT MSG="Bed: {target_bed}c"
	STATUS_HEATING
	G1 X{x_wait} Y{y_wait} Z15 F9000
	M190 S{target_bed}
	SET_DISPLAY_TEXT MSG="Soak for 5min"
	G4 P300000
	{% endif %}
	
	
	SET_DISPLAY_TEXT MSG="Hotend: 150c"
	M109 S150
	
	
	SET_DISPLAY_TEXT MSG="QGL"
	STATUS_LEVELING
	quad_gantry_level
	G28 Z
	
	
	SET_DISPLAY_TEXT MSG="Bed mesh"
	STATUS_MESHING
	BED_MESH_CALIBRATE
	
	
	SET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"
	STATUS_HEATING
	G1 X{x_wait} Y{y_wait} Z15 F9000
	M107
	M109 S{target_extruder}
	
	
	SET_DISPLAY_TEXT MSG="printing..."
	STATUS_PRINTING
	NOZZLE_CLEAN
	LINE_PURGE

[gcode_macro SHUTDOWN]
gcode = 
	
	OFF
	{action_respond_info('action:poweroff')}
	{action_call_remote_method("shutdown_machine")}

[gcode_macro BED_MESH_CALIBRATE]
rename_existing = _BED_MESH_CALIBRATE
gcode = 
	
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}
	{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}
	{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}
	{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}
	{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}
	{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}
	{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}
	{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}
	{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}
	{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}
	{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}
	{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}
	{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}
	{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}
	{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}
	{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}
	
	{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}
	{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}
	{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}
	{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}
	{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}
	
	{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}
	{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}
	{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}
	{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}
	
	{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method='ceil') | int) + 1 %}
	{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method='ceil') | int) + 1 %}
	
	{% if (([points_x, points_y]|max) > 6) %}
	{% set algorithm = "bicubic" %}
	{% set min_points = 4 %}
	{% else %}
	{% set algorithm = "lagrange" %}
	{% set min_points = 3 %}
	{% endif %}
	
	{% set points_x = [points_x , min_points]|max %}
	{% set points_y = [points_y , min_points]|max %}
	{% set points_x = [points_x , probe_count[0]]|min %}
	{% set points_y = [points_y , probe_count[1]]|min %}
	
	{% if verbose_enable == True %}
	
	{ action_respond_info( "Algorithm: {}.".format(
	(algorithm),
	)) }
	
	{ action_respond_info("Default probe count: {},{}.".format(
	(probe_count[0]),
	(probe_count[1]),
	)) }
	
	{ action_respond_info("Adapted probe count: {},{}.".format(
	(points_x),
	(points_y),
	)) }
	
	{action_respond_info("Default mesh bounds: {}, {}.".format(
	(bed_mesh_min[0],bed_mesh_min[1]),
	(bed_mesh_max[0],bed_mesh_max[1]),
	)) }
	
	{% if mesh_margin > 0 %}
	{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(
	(mesh_margin),
	(mesh_margin),
	)) }
	{% else %}
	{action_respond_info("Mesh margin is 0, margin not increased.")}
	{% endif %}
	
	{% if fuzz_amount > 0 %}
	{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(
	(fuzz_amount),
	)) }
	{% else %}
	{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}
	{% endif %}
	
	{ action_respond_info("Adapted mesh bounds: {}, {}.".format(
	(adapted_x_min, adapted_y_min),
	(adapted_x_max, adapted_y_max),
	)) }
	
	{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}
	
	{% endif %}
	
	{% if probe_dock_enable == True %}
	{attach_macro}
	{% endif %}
	
	_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}
	
	{% if probe_dock_enable == True %}
	{detach_macro}
	{% endif %}

[gcode_macro _KAMP_Settings]
description = This macro contains all adjustable settings for KAMP
variable_verbose_enable = True
variable_mesh_margin = 0
variable_fuzz_amount = 0
variable_probe_dock_enable = False
variable_attach_macro = 'Attach_Probe'
variable_detach_macro = 'Dock_Probe'
variable_purge_height = 0.8
variable_tip_distance = 0
variable_purge_margin = 10
variable_purge_amount = 30
variable_flow_rate = 12
variable_smart_park_height = 10
gcode = 
	
	{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}

[gcode_macro LINE_PURGE]
description = A purge macro that adapts to be near your actual printed objects
gcode = 
	
	{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}
	{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}
	
	
	{% if printer.firmware_retraction is defined %}
	{% set RETRACT = G10 | string %}
	{% set UNRETRACT = G11 | string %}
	{% else %}
	{% set RETRACT = 'G1 E-.5 F2100' | string %}
	{% set UNRETRACT = 'G1 E.5 F2100' | string %}
	{% endif %}
	
	
	{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}
	{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}
	{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}
	{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}
	{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}
	{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}
	
	
	
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}
	{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}
	{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}
	{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}
	
	{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}
	{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}
	
	{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}
	{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}
	
	
	{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}
	
	{% if cross_section < 5 %}
	
	{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}
	
	{% else %}
	
	{% if verbose_enable == True %}
	
	{action_respond_info("Moving filament tip {}mms".format(
	(tip_distance),
	)) }
	{% endif %}
	
	{% if printer.firmware_retraction is defined %}
	{action_respond_info("KAMP purge is using firmware retraction.")}
	{% else %}
	{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}
	{% endif %}
	
	{% if purge_y_origin > 0 %}
	
	{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(
	(purge_x_center),
	(purge_y_origin),
	(purge_amount),
	(flow_rate),
	)) }
	
	{% else %}
	
	{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(
	(purge_x_origin),
	(purge_y_center),
	(purge_amount),
	(flow_rate),
	)) }
	
	{% endif %}
	
	SAVE_GCODE_STATE NAME=Prepurge_State
	
	{% if purge_y_origin > 0 %}
	
	G92 E0
	G0 F{travel_speed}
	G90
	G0 X{purge_x_center} Y{purge_y_origin}
	G0 Z{purge_height}
	M83
	G1 E{tip_distance} F{purge_move_speed}
	G1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}
	{RETRACT}
	G0 X{purge_x_center + purge_amount + 10} F{travel_speed}
	G92 E0
	M82
	G0 Z{purge_height * 2} F{travel_speed}
	
	{% else %}
	
	G92 E0
	G0 F{travel_speed}
	G90
	G0 X{purge_x_origin} Y{purge_y_center}
	G0 Z{purge_height}
	M83
	G1 E{tip_distance} F{purge_move_speed}
	G1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}
	{RETRACT}
	G0 Y{purge_y_center + purge_amount + 10} F{travel_speed}
	G92 E0
	M82
	G0 Z{purge_height * 2} F{travel_speed}
	
	{% endif %}
	
	RESTORE_GCODE_STATE NAME=Prepurge_State
	
	{% endif %}

[gcode_macro SMART_PARK]
description = Parks your printhead near the print area for pre-print hotend heating.
gcode = 
	
	{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}
	{% set z_height = kamp_settings.smart_park_height | float %}
	{% set purge_margin = kamp_settings.purge_margin | float %}
	{% set verbose_enable = kamp_settings.verbose_enable | abs %}
	{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}
	{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}
	{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}
	{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}
	
	{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}
	{% set x_min = [ x_min - purge_margin , x_min ] | max %}
	{% set y_min = [ y_min - purge_margin , y_min ] | max %}
	{% endif %}
	
	
	{% if verbose_enable == True %}
	
	{ action_respond_info("Smart Park location: {},{}.".format(
	(x_min),
	(y_min),
	)) }
	
	{% endif %}
	
	G0 X{x_min} Y{y_min} F{travel_speed}
	G0 Z{z_height}

[gcode_macro VORON_PURGE]
description = A purge macro that adapts to be near your actual printed objects
gcode = 
	
	{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}
	{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}
	
	
	{% if printer.firmware_retraction is defined %}
	{% set RETRACT = G10 | string %}
	{% set UNRETRACT = G11 | string %}
	{% else %}
	{% set RETRACT = 'G1 E-.5 F2100' | string %}
	{% set UNRETRACT = 'G1 E.5 F2100' | string %}
	{% endif %}
	
	
	{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}
	{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}
	{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}
	{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}
	{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}
	{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}
	{% set size = 10 | float %}
	
	
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}
	{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}
	{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}
	{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}
	
	{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}
	{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}
	
	{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}
	{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}
	
	
	{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}
	
	{% if cross_section < 5 %}
	
	{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}
	
	{% else %}
	
	{% if verbose_enable == True %}
	
	{action_respond_info("Moving filament tip {}mms".format(
	(tip_distance),
	)) }
	{% endif %}
	
	{% if printer.firmware_retraction is defined %}
	{action_respond_info("KAMP purge is using firmware retraction.")}
	{% else %}
	{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}
	{% endif %}
	
	SAVE_GCODE_STATE NAME=Prepurge_State
	
	G92 E0
	G0 F{travel_speed}
	G90
	G0 X{purge_x_origin} Y{purge_y_origin+size/2}
	G0 Z{purge_height}
	M83
	G1 E{tip_distance} F{purge_move_speed}
	G1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}
	G1 E-.5 F2100
	G0 Z{purge_height*2}
	G0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}
	G0 Z{purge_height}
	G1 E.5 F2100
	G1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}
	G1 E-.5 F2100
	G0 Z{purge_height*2}
	G0 X{purge_x_origin+size*0.711} Y{purge_y_origin}
	G0 Z{purge_height}
	G1 E.5 F2100
	G1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}
	G1 E-.5 F2100
	G92 E0
	M82
	G0 Z{purge_height*2} F{travel_speed}
	
	RESTORE_GCODE_STATE NAME=Prepurge_State
	
	{% endif %}

[exclude_object]

[printer]
kinematics = corexy
max_velocity = 300
max_accel = 3000
max_z_velocity = 15
max_z_accel = 350
square_corner_velocity = 5.0

[idle_timeout]
timeout = 1800

[extruder]
step_pin = SB2240: PD0
dir_pin = SB2240: PD1
enable_pin = !SB2240: PD2
rotation_distance = 21.6357193494
gear_ratio = 50:10
microsteps = 16
full_steps_per_rotation = 200
nozzle_diameter = 0.400
filament_diameter = 1.750
heater_pin = SB2240: PB13
sensor_type = EPCOS 100K B57560G104F
sensor_pin = SB2240: PA3
min_temp = 0
max_temp = 280
min_extrude_temp = 190
control = pid
pid_kp = 31.337
pid_ki = 3.798
pid_kd = 64.635

[tmc2240 extruder]
cs_pin = SB2240: PA15
spi_software_sclk_pin = SB2240: PB10
spi_software_mosi_pin = SB2240: PB11
spi_software_miso_pin = SB2240: PB2
driver_tpfd = 0
run_current = 0.4
stealthchop_threshold = 0

[heater_bed]
heater_pin = PB7
sensor_type = Generic 3950
sensor_pin = PA0
max_power = 1
min_temp = 0
max_temp = 120
control = pid
pid_kp = 57.515
pid_ki = 2.719
pid_kd = 304.113

[probe]
activate_gcode = 
	{% set PROBE_TEMP = 150 %}
	{% set MAX_TEMP = PROBE_TEMP + 5 %}
	{% set ACTUAL_TEMP = printer.extruder.temperature %}
	{% set TARGET_TEMP = printer.extruder.target %}
	
	{% if TARGET_TEMP > PROBE_TEMP %}
	{ action_respond_info('Extruder temperature target of %.1fC is too high, lowering to %.1fC' % (TARGET_TEMP, PROBE_TEMP)) }
	M109 S{ PROBE_TEMP }
	{% else %}
	
	{% if ACTUAL_TEMP > MAX_TEMP %}
	{ action_respond_info('Extruder temperature %.1fC is still too high, waiting until below %.1fC' % (ACTUAL_TEMP, MAX_TEMP)) }
	TEMPERATURE_WAIT SENSOR=extruder MAXIMUM={ MAX_TEMP }
	{% endif %}
	{% endif %}
pin = !SB2240: PC13
x_offset = 0
y_offset = 0
speed = 20
samples = 3
samples_result = median
sample_retract_dist = 1.0
samples_tolerance = 0.006
samples_tolerance_retries = 20
lift_speed = 200
z_offset = -0.875

[bed_mesh default]
version = 1
points = 
	-0.007547, -0.008172, -0.023328
	-0.003016, 0.006672, -0.006766
	0.002922, -0.011297, 0.000266
x_count = 3
y_count = 3
mesh_x_pps = 2
mesh_y_pps = 2
algo = lagrange
tension = 0.2
min_x = 148.04
max_x = 202.1
min_y = 107.62
max_y = 193.22
=======================
Extruder max_extrude_ratio=0.266081
mcu 'mcu': Starting serial connect
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
webhooks client 548262882944: New connection
webhooks client 548262882944: Client info {'program': 'Moonraker', 'version': 'v0.8.0-286-gf44fc4b'}
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
MCU error during connect
Traceback (most recent call last):
  File "/home/pi/klipper/klippy/mcu.py", line 768, in _mcu_identify
    self._serial.connect_uart(self._serialport, self._baud, rts)
  File "/home/pi/klipper/klippy/serialhdl.py", line 182, in connect_uart
    self._error("Unable to connect")
  File "/home/pi/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Unable to connect

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/pi/klipper/klippy/klippy.py", line 176, in _connect
    self.send_event("klippy:mcu_identify")
  File "/home/pi/klipper/klippy/klippy.py", line 263, in send_event
    return [cb(*params) for cb in self.event_handlers.get(event, [])]
  File "/home/pi/klipper/klippy/klippy.py", line 263, in <listcomp>
    return [cb(*params) for cb in self.event_handlers.get(event, [])]
  File "/home/pi/klipper/klippy/mcu.py", line 773, in _mcu_identify
    raise error(str(e))
mcu.error: mcu 'mcu': Unable to connect
Build file /home/pi/klipper/klippy/../.config(3445): Fri Jan 26 22:28:46 2024
========= Last MCU build config =========
CONFIG_LOW_LEVEL_OPTIONS=y
# CONFIG_MACH_AVR is not set
# CONFIG_MACH_ATSAM is not set
# CONFIG_MACH_ATSAMD is not set
# CONFIG_MACH_LPC176X is not set
CONFIG_MACH_STM32=y
# CONFIG_MACH_HC32F460 is not set
# CONFIG_MACH_RP2040 is not set
# CONFIG_MACH_PRU is not set
# CONFIG_MACH_AR100 is not set
# CONFIG_MACH_LINUX is not set
# CONFIG_MACH_SIMU is not set
CONFIG_BOARD_DIRECTORY="stm32"
CONFIG_MCU="stm32g0b1xx"
CONFIG_CLOCK_FREQ=64000000
CONFIG_USBSERIAL=y
CONFIG_FLASH_SIZE=0x20000
CONFIG_FLASH_BOOT_ADDRESS=0x8000000
CONFIG_RAM_START=0x20000000
CONFIG_RAM_SIZE=0x24000
CONFIG_STACK_SIZE=512
CONFIG_FLASH_APPLICATION_ADDRESS=0x8002000
CONFIG_STM32_SELECT=y
# CONFIG_MACH_STM32F103 is not set
# CONFIG_MACH_STM32F207 is not set
# CONFIG_MACH_STM32F401 is not set
# CONFIG_MACH_STM32F405 is not set
# CONFIG_MACH_STM32F407 is not set
# CONFIG_MACH_STM32F429 is not set
# CONFIG_MACH_STM32F446 is not set
# CONFIG_MACH_STM32F765 is not set
# CONFIG_MACH_STM32F031 is not set
# CONFIG_MACH_STM32F042 is not set
# CONFIG_MACH_STM32F070 is not set
# CONFIG_MACH_STM32F072 is not set
# CONFIG_MACH_STM32G070 is not set
# CONFIG_MACH_STM32G071 is not set
# CONFIG_MACH_STM32G0B0 is not set
CONFIG_MACH_STM32G0B1=y
# CONFIG_MACH_STM32G431 is not set
# CONFIG_MACH_STM32H723 is not set
# CONFIG_MACH_STM32H743 is not set
# CONFIG_MACH_STM32H750 is not set
# CONFIG_MACH_STM32L412 is not set
# CONFIG_MACH_N32G452 is not set
# CONFIG_MACH_N32G455 is not set
CONFIG_MACH_STM32G0=y
CONFIG_MACH_STM32G0Bx=y
CONFIG_HAVE_STM32_USBFS=y
CONFIG_HAVE_STM32_FDCANBUS=y
CONFIG_HAVE_STM32_USBCANBUS=y
CONFIG_STM32_DFU_ROM_ADDRESS=0x1fff0000
CONFIG_STM32_FLASH_START_2000=y
# CONFIG_STM32_FLASH_START_0000 is not set
CONFIG_STM32_CLOCK_REF_8M=y
# CONFIG_STM32_CLOCK_REF_12M is not set
# CONFIG_STM32_CLOCK_REF_16M is not set
# CONFIG_STM32_CLOCK_REF_20M is not set
# CONFIG_STM32_CLOCK_REF_24M is not set
# CONFIG_STM32_CLOCK_REF_25M is not set
# CONFIG_STM32_CLOCK_REF_INTERNAL is not set
CONFIG_CLOCK_REF_FREQ=8000000
CONFIG_STM32F0_TRIM=16
CONFIG_STM32_USB_PA11_PA12=y
# CONFIG_STM32_SERIAL_USART1 is not set
# CONFIG_STM32_SERIAL_USART1_ALT_PB7_PB6 is not set
# CONFIG_STM32_SERIAL_USART2 is not set
# CONFIG_STM32_SERIAL_USART2_ALT_PD6_PD5 is not set
# CONFIG_STM32_SERIAL_USART3 is not set
# CONFIG_STM32_SERIAL_USART3_ALT_PD9_PD8 is not set
# CONFIG_STM32_SERIAL_USART5 is not set
# CONFIG_STM32_CANBUS_PA11_PA12 is not set
# CONFIG_STM32_CANBUS_PA11_PB9 is not set
# CONFIG_STM32_MMENU_CANBUS_PB8_PB9 is not set
# CONFIG_STM32_MMENU_CANBUS_PB12_PB13 is not set
# CONFIG_STM32_MMENU_CANBUS_PD0_PD1 is not set
# CONFIG_STM32_MMENU_CANBUS_PB0_PB1 is not set
# CONFIG_STM32_MMENU_CANBUS_PD12_PD13 is not set
# CONFIG_STM32_MMENU_CANBUS_PC2_PC3 is not set
# CONFIG_STM32_USBCANBUS_PA11_PA12 is not set
CONFIG_USB=y
CONFIG_USB_VENDOR_ID=0x1d50
CONFIG_USB_DEVICE_ID=0x614e
CONFIG_USB_SERIAL_NUMBER_CHIPID=y
CONFIG_USB_SERIAL_NUMBER="12345"

#
# USB ids
#
# end of USB ids

CONFIG_WANT_GPIO_BITBANGING=y
CONFIG_WANT_DISPLAYS=y
CONFIG_WANT_SENSORS=y
CONFIG_WANT_LIS2DW=y
CONFIG_WANT_SOFTWARE_I2C=y
CONFIG_WANT_SOFTWARE_SPI=y
CONFIG_NEED_SENSOR_BULK=y
CONFIG_CANBUS_FREQUENCY=1000000
CONFIG_INITIAL_PINS=""
CONFIG_HAVE_GPIO=y
CONFIG_HAVE_GPIO_ADC=y
CONFIG_HAVE_GPIO_SPI=y
CONFIG_HAVE_GPIO_I2C=y
CONFIG_HAVE_GPIO_HARD_PWM=y
CONFIG_HAVE_STRICT_TIMING=y
CONFIG_HAVE_CHIPID=y
CONFIG_HAVE_STEPPER_BOTH_EDGE=y
CONFIG_HAVE_BOOTLOADER_REQUEST=y
CONFIG_INLINE_STEPPER_HACK=y
=======================
Build file /home/pi/klipper/klippy/../out/klipper.dict(7720): Fri Jan 26 22:29:04 2024
Last MCU build version: v0.12.0-98-g5e433fff
Last MCU build tools: gcc: (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc-8-branch revision 273027] binutils: (2.35.2-2+14+b2) 2.35.2
Last MCU build config: ADC_MAX=4095 BUS_PINS_i2c1_PA9_PA10=PA9,PA10 BUS_PINS_i2c1_PB6_PB7=PB6,PB7 BUS_PINS_i2c1_PB8_PB9=PB8,PB9 BUS_PINS_i2c2_PB10_PB11=PB10,PB11 BUS_PINS_i2c2_PB13_PB14=PB13,PB14 BUS_PINS_i2c3_PB3_PB4=PB3,PB4 BUS_PINS_spi1=PA6,PA7,PA5 BUS_PINS_spi1a=PB4,PB5,PB3 BUS_PINS_spi2=PB14,PB15,PB13 BUS_PINS_spi2a=PC2,PC3,PB10 BUS_PINS_spi3=PB4,PB5,PB3 CLOCK_FREQ=64000000 MCU=stm32g0b1xx PWM_MAX=255 RESERVE_PINS_USB=PA11,PA12 RESERVE_PINS_crystal=PF0,PF1 STATS_SUMSQ_BASE=256 STEPPER_BOTH_EDGE=1
Build file /home/pi/klipper/klippy/../out/klipper.elf(1057236): Fri Jan 26 22:29:11 2024
Starting Klippy...
Args: ['/home/pi/klipper/klippy/klippy.py', '/home/pi/printer_data/config/printer.cfg', '-I', '/home/pi/printer_data/comms/klippy.serial', '-l', '/home/pi/printer_data/logs/klippy.log', '-a', '/home/pi/printer_data/comms/klippy.sock']
Git version: 'v0.12.0-98-g5e433fff-dirty'
Untracked files: klippy/extras/gcode_shell_command.py
Branch: master
Remote: origin
Tracked URL: https://github.com/Klipper3d/klipper
CPU: 4 core ?
Python: '3.9.2 (default, Feb 28 2021, 17:03:44) \n[GCC 10.2.1 20210110]'
Start printer at Fri Jan 26 22:45:09 2024 (1706309109.8 19.1)
===== Config file =====
[gcode_shell_command hello_world]
command = echo hello world
timeout = 2.
verbose = True

[gcode_macro HELLO_WORLD]
gcode = 
	RUN_SHELL_COMMAND CMD=hello_world

[virtual_sdcard]
path = ~/printer_data/gcodes
on_error_gcode = CANCEL_PRINT

[pause_resume]

[display_status]

[respond]

[gcode_macro CANCEL_PRINT]
description = Cancel the actual running print
rename_existing = BASE_CANCEL_PRINT
gcode = 
	SET_IDLE_TIMEOUT TIMEOUT={printer.configfile.settings.idle_timeout.timeout}
	CLEAR_PAUSE
	SDCARD_RESET_FILE
	PRINT_END
	BASE_CANCEL_PRINT

[gcode_macro PAUSE]
description = Pause the actual running print
rename_existing = BASE_PAUSE
variable_restore_idle_timeout = 0
gcode = 
	
	{% set z = params.Z|default(10)|int %}
	
	{% if printer['pause_resume'].is_paused|int == 0 %}
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=zhop VALUE={z}
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=etemp VALUE={printer['extruder'].target}
	
	SET_FILAMENT_SENSOR SENSOR=filament_sensor ENABLE=0
	SAVE_GCODE_STATE NAME=PAUSE
	BASE_PAUSE
	{% if (printer.gcode_move.position.z + z) < printer.toolhead.axis_maximum.z %}
	G91
	G1 Z{z} F900
	{% else %}
	{ action_respond_info("Pause zhop exceeds maximum Z height.") }
	SET_GCODE_VARIABLE MACRO=RESUME VARIABLE=zhop VALUE=0
	{% endif %}
	G90
	G1 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_minimum.y+5} F6000
	SAVE_GCODE_STATE NAME=PAUSEPARK
	M104 S0
	SET_IDLE_TIMEOUT TIMEOUT=43200
	{% endif %}

[gcode_macro RESUME]
description = Resume the actual running print
rename_existing = BASE_RESUME
variable_last_extruder_temp = {'restore': False, 'temp': 0}
gcode = 
	
	{% set e = params.E|default(2.5)|int %}
	
	{% if printer['pause_resume'].is_paused|int == 1 %}
	SET_FILAMENT_SENSOR SENSOR=filament_sensor ENABLE=1
	
	SET_IDLE_TIMEOUT TIMEOUT={printer.configfile.settings.idle_timeout.timeout}
	{% if etemp > 0 %}
	M109 S{etemp|int}
	{% endif %}
	RESTORE_GCODE_STATE NAME=PAUSEPARK MOVE=1 MOVE_SPEED=100
	G91
	M83
	{% if printer[printer.toolhead.extruder].temperature >= printer.configfile.settings.extruder.min_extrude_temp %}
	G1 Z{zhop * -1} E{e} F900
	{% else %}
	G1 Z{zhop * -1} F900
	{% endif %}
	RESTORE_GCODE_STATE NAME=PAUSE MOVE=1 MOVE_SPEED=60
	BASE_RESUME
	{% endif %}
variable_zhop = 0
variable_etemp = 0

[gcode_macro SET_PAUSE_NEXT_LAYER]
description = Enable a pause if the next layer is reached
gcode = 
	{% set pause_next_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_next_layer %}
	{% set ENABLE = params.ENABLE|default(1)|int != 0 %}
	{% set MACRO = params.MACRO|default(pause_next_layer.call, True) %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_next_layer VALUE="{{ 'enable': ENABLE, 'call': MACRO }}"

[gcode_macro SET_PAUSE_AT_LAYER]
description = Enable/disable a pause if a given layer number is reached
gcode = 
	{% set pause_at_layer = printer['gcode_macro SET_PRINT_STATS_INFO'].pause_at_layer %}
	{% set ENABLE = params.ENABLE|int != 0 if params.ENABLE is defined
	else params.LAYER is defined %}
	{% set LAYER = params.LAYER|default(pause_at_layer.layer)|int %}
	{% set MACRO = params.MACRO|default(pause_at_layer.call, True) %}
	SET_GCODE_VARIABLE MACRO=SET_PRINT_STATS_INFO VARIABLE=pause_at_layer VALUE="{{ 'enable': ENABLE, 'layer': LAYER, 'call': MACRO }}"

[gcode_macro SET_PRINT_STATS_INFO]
rename_existing = SET_PRINT_STATS_INFO_BASE
description = Overwrite, to get pause_next_layer and pause_at_layer feature
variable_pause_next_layer = { 'enable': False, 'call': "PAUSE" }
variable_pause_at_layer = { 'enable': False, 'layer': 0, 'call': "PAUSE" }
gcode = 
	{% if pause_next_layer.enable %}
	RESPOND TYPE=echo MSG='{"%s, forced by pause_next_layer" % pause_next_layer.call}'
	{pause_next_layer.call}
	SET_PAUSE_NEXT_LAYER ENABLE=0
	{% elif pause_at_layer.enable and params.CURRENT_LAYER is defined and params.CURRENT_LAYER|int == pause_at_layer.layer %}
	RESPOND TYPE=echo MSG='{"%s, forced by pause_at_layer [%d]" % (pause_at_layer.call, pause_at_layer.layer)}'
	{pause_at_layer.call}
	SET_PAUSE_AT_LAYER ENABLE=0
	{% endif %}
	SET_PRINT_STATS_INFO_BASE {rawparams}

[gcode_macro _TOOLHEAD_PARK_PAUSE_CANCEL]
description = Helper: park toolhead used in PAUSE and CANCEL_PRINT
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set velocity = printer.configfile.settings.pause_resume.recover_velocity %}
	{% set use_custom     = client.use_custom_pos|default(false)|lower == 'true' %}
	{% set custom_park_x  = client.custom_park_x|default(0.0) %}
	{% set custom_park_y  = client.custom_park_y|default(0.0) %}
	{% set park_dz        = client.custom_park_dz|default(2.0)|abs %}
	{% set sp_hop         = client.speed_hop|default(15) * 60 %}
	{% set sp_move        = client.speed_move|default(velocity) * 60 %}
	
	{% set origin    = printer.gcode_move.homing_origin %}
	{% set act       = printer.gcode_move.gcode_position %}
	{% set max       = printer.toolhead.axis_maximum %}
	{% set cone      = printer.toolhead.cone_start_z|default(max.z) %}
	{% set round_bed = True if printer.configfile.settings.printer.kinematics is in ['delta','polar','rotary_delta','winch']
	else False %}
	
	{% set z_min = params.Z_MIN|default(0)|float %}
	{% set z_park = [[(act.z + park_dz), z_min]|max, (max.z - origin.z)]|min %}
	{% set x_park = params.X       if params.X is defined
	else custom_park_x  if use_custom
	else 0.0            if round_bed
	else (max.x - 5.0) %}
	{% set y_park = params.Y       if params.Y is defined
	else custom_park_y  if use_custom
	else (max.y - 5.0)  if round_bed and z_park < cone
	else 0.0            if round_bed
	else (max.y - 5.0) %}
	
	_CLIENT_RETRACT
	{% if "xyz" in printer.toolhead.homed_axes %}
	G90
	G1 Z{z_park} F{sp_hop}
	G1 X{x_park} Y{y_park} F{sp_move}
	{% if not printer.gcode_move.absolute_coordinates %} G91 {% endif %}
	{% else %}
	RESPOND TYPE=echo MSG='Printer not homed'
	{% endif %}

[gcode_macro _CLIENT_EXTRUDE]
description = Extrudes, if the extruder is hot enough
gcode = 
	
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set use_fw_retract = (client.use_fw_retract|default(false)|lower == 'true') and (printer.firmware_retraction is defined) %}
	{% set length = params.LENGTH|default(client.unretract)|default(1.0)|float %}
	{% set speed = params.SPEED|default(client.speed_unretract)|default(35) %}
	{% set absolute_extrude = printer.gcode_move.absolute_extrude %}
	
	{% if printer.toolhead.extruder != '' %}
	{% if printer[printer.toolhead.extruder].can_extrude %}
	{% if use_fw_retract %}
	{% if length < 0 %}
	G10
	{% else %}
	G11
	{% endif %}
	{% else %}
	M83
	G1 E{length} F{(speed|float|abs) * 60}
	{% if absolute_extrude %}
	M82
	{% endif %}
	{% endif %}
	{% else %}
	RESPOND TYPE=echo MSG='Extruder not hot enough'
	{% endif %}
	{% endif %}

[gcode_macro _CLIENT_RETRACT]
description = Retracts, if the extruder is hot enough
gcode = 
	{% set client = printer['gcode_macro _CLIENT_VARIABLE']|default({}) %}
	{% set length = params.LENGTH|default(client.retract)|default(1.0)|float %}
	{% set speed = params.SPEED|default(client.speed_retract)|default(35) %}
	
	_CLIENT_EXTRUDE LENGTH=-{length|float|abs} SPEED={speed|float|abs}

[adxl345]
cs_pin = SB2240: PB12
spi_software_sclk_pin = SB2240: PB10
spi_software_mosi_pin = SB2240: PB11
spi_software_miso_pin = SB2240: PB2
axes_map = z,-y,x

[resonance_tester]
probe_points = 100, 100, 20
accel_chip = adxl345

[bed_mesh]
speed = 300
horizontal_move_z = 1
mesh_min = 40, 40
mesh_max = 310,310
zero_reference_position = 175,175
fade_start = 0.6
fade_end = 10.0
probe_count = 5,5
algorithm = bicubic

[fan]
pin = SB2240: PA1
kick_start_time = 0.5
off_below = 0.09

[heater_fan hotend_fan]
pin = SB2240: PA0
max_power = 1.0
kick_start_time = 0.5
heater = extruder
heater_temp = 50.0

[board_pins]
aliases = 
	
	EXP1_1=PE9, EXP1_2=PE10,
	EXP1_3=PE11, EXP1_4=PE12,
	EXP1_5=PE13, EXP1_6=PE14,
	EXP1_7=PE15, EXP1_8=PB10,
	EXP1_9=<GND>, EXP1_10=<5V>,
	
	
	EXP2_1=PB14, EXP2_2=PB13,
	EXP2_3=PF7, EXP2_4=PB12,
	EXP2_5=PE7, EXP2_6=PB11,
	EXP2_7=PE8, EXP2_8=<RST>,
	EXP2_9=<GND>, EXP2_10=PC5

[display]
lcd_type = uc1701
cs_pin = EXP1_3
a0_pin = EXP1_4
rst_pin = EXP1_5
encoder_pins = ^EXP2_5, ^EXP2_3
click_pin = ^!EXP1_2
contrast = 63
spi_software_miso_pin = EXP2_1
spi_software_mosi_pin = EXP2_6
spi_software_sclk_pin = EXP2_2

[neopixel btt_mini12864]
pin = EXP1_6
chain_count = 3
initial_red = 0.1
initial_green = 0.5
initial_blue = 0.0
color_order = RGB

[delayed_gcode setdisplayneopixel]
initial_duration = 1
gcode = 
	SET_LED LED=btt_mini12864 RED=1 GREEN=1 BLUE=1 INDEX=1 TRANSMIT=0
	SET_LED LED=btt_mini12864 RED=1 GREEN=0 BLUE=0 INDEX=2 TRANSMIT=0
	SET_LED LED=btt_mini12864 RED=1 GREEN=0 BLUE=0 INDEX=3

[mcu]
serial = /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00
restart_method = command

[mcu SB2240]
canbus_uuid = 1d98beae65e3

[quad_gantry_level]
gantry_corners = 
	-60,-10
	410,420
points = 
	50,25
	50,275
	300,275
	300,25
speed = 400
horizontal_move_z = 5
retries = 5
retry_tolerance = 0.0075
max_adjust = 10

[safe_z_home]
home_xy_position = 175,175
speed = 150
z_hop = 10

[stepper_x]
step_pin = PE2
dir_pin = PB4
enable_pin = !PC11
microsteps = 128
rotation_distance = 40
full_steps_per_rotation = 200
endstop_pin = ^PF3
position_min = 0
position_endstop = 350
position_max = 350
homing_speed = 100
homing_retract_dist = 5
homing_positive_dir = true

[tmc2209 stepper_x]
uart_pin = PC10
interpolate = True
run_current = 0.8
stealthchop_threshold = 0

[stepper_y]
step_pin = PF12
dir_pin = PF11
enable_pin = !PB3
microsteps = 128
rotation_distance = 40
endstop_pin = ^PF4
full_steps_per_rotation = 200
position_min = 0
position_endstop = 350
position_max = 350
homing_speed = 100
homing_retract_dist = 5
homing_positive_dir = true

[tmc2209 stepper_y]
uart_pin = PF13
interpolate = True
run_current = 0.8
stealthchop_threshold = 0

[stepper_z]
step_pin = PD7
dir_pin = PD6
enable_pin = !PF10
rotation_distance = 40
gear_ratio = 80:16
microsteps = 256
endstop_pin = probe:z_virtual_endstop
position_max = 340
position_min = -5
homing_speed = 8
second_homing_speed = 3
homing_retract_dist = 3

[tmc2209 stepper_z]
uart_pin = PF9
interpolate = true
run_current = 0.6
stealthchop_threshold = 999999

[stepper_z1]
step_pin = PC9
dir_pin = !PC8
enable_pin = !PD1
rotation_distance = 40
gear_ratio = 80:16
microsteps = 256

[tmc2209 stepper_z1]
uart_pin = PD0
interpolate = true
run_current = 0.6
stealthchop_threshold = 999999

[stepper_z2]
step_pin = PA10
dir_pin = PD15
enable_pin = !PA15
rotation_distance = 40
gear_ratio = 80:16
microsteps = 256

[tmc2209 stepper_z2]
uart_pin = PF8
interpolate = true
run_current = 0.6
stealthchop_threshold = 999999

[stepper_z3]
step_pin = PD12
dir_pin = !PD11
enable_pin = !PD14
rotation_distance = 40
gear_ratio = 80:16
microsteps = 256

[tmc2209 stepper_z3]
uart_pin = PD13
interpolate = true
run_current = 0.6
stealthchop_threshold = 999999

[temperature_sensor M8P]
sensor_type = temperature_mcu
min_temp = 0
max_temp = 100

[temperature_sensor CM4]
sensor_type = temperature_host
min_temp = 10
max_temp = 100

[temperature_sensor SB2240]
sensor_type = temperature_mcu
sensor_mcu = SB2240
min_temp = 0
max_temp = 100

[gcode_macro update_git]
gcode = 
	RUN_SHELL_COMMAND CMD=update_git_script

[gcode_shell_command update_git_script]
command = bash /home/pi/klipper-backup/script.sh
timeout = 90.0
verbose = True

[gcode_macro DUMP_VARIABLES]
gcode = 
	{% set filter_name = params.NAME|default('')|string|lower %}
	{% set filter_value = params.VALUE|default('')|string|lower %}
	{% set show_cfg = params.SHOW_CFG|default(0)|int %}
	
	{% set out = [] %}
	
	{% for key1 in printer %}
	{% for key2 in printer[key1] %}
	{% if (show_cfg or not (key1|lower == 'configfile' and key2|lower in ['config', 'settings'])) and (filter_name in key1|lower or filter_name in key2|lower) and filter_value in printer[key1][key2]|string|lower %}
	{% set dummy = out.append("printer['%s'].%s = %s" % (key1, key2, printer[key1][key2])) %}
	{% endif %}
	{% else %}
	{% if filter_name in key1|lower and filter_value in printer[key1]|string|lower %}
	{% set dummy = out.append("printer['%s'] = %s" % (key1, printer[key1])) %}
	{% endif %}
	{% endfor %}
	{% endfor %}
	
	{action_respond_info(out|join("\n"))}

[gcode_macro G32]
gcode = 
	BED_MESH_CLEAR
	G28
	QUAD_GANTRY_LEVEL
	G28

[gcode_macro GET_VARIABLE]
gcode = 
	{% set names = (params.NAME).split('.')|list %}
	{% set join = (params.JOIN)|default(1)|int %}
	
	{% set _dummy0 = namespace( break = 0 ) %}
	{% set _dummy1 = namespace( out = printer[names|first] ) %}
	
	{% for name in names if _dummy0.break == 0 %}
	{% if loop.index > 1 %}
	{% if name in _dummy1.out %}
	{% set _dummy1.out = _dummy1.out[name] %}
	{% elif name[0] in '0123456789' and _dummy1.out is iterable and _dummy1.out is not string and _dummy1.out is not mapping and _dummy1.out|length > name[0]|int %}
	{% set _dummy1.out = _dummy1.out[name|int] %}
	{% else %}
	{% set _dummy0.break = loop.index0 %}
	{% endif %}
	{% endif %}
	{% endfor %}
	
	{% if _dummy1.out is boolean %}
	{ action_respond_info('Type: boolean') }
	{% elif _dummy1.out is float %}
	{ action_respond_info('Type: float') }
	{% elif _dummy1.out is integer %}
	{ action_respond_info('Type: integer') }
	{% elif _dummy1.out is mapping %}
	{ action_respond_info('Type: mapping') }
	{% elif _dummy1.out is string %}
	{ action_respond_info('Type: string') }
	{% elif _dummy1.out is iterable %}
	{ action_respond_info('Type: iterable') }
	{% elif _dummy1.out is none %}
	{ action_respond_info('Type: none') }
	{% elif _dummy1.out is undefined %}
	{ action_respond_info('Type: undefined') }
	{% elif _dummy1.out is callable %}
	{ action_respond_info('Type: callable') }
	{% else %}
	{ action_respond_info('Type: unknown') }
	{% endif %}
	
	{% if join and _dummy1.out is iterable and _dummy1.out is not string and _dummy1.out is not mapping %}
	{ action_respond_info('%s' % _dummy1.out|join("\n")) }
	{% else %}
	{ action_respond_info('%s' % _dummy1.out) }
	{% endif %}
	
	{% if _dummy0.break != 0 %}
	{ action_respond_info('"printer.%s" does not contain "%s"!' % (names[0:_dummy0.break]|join('.'), names[_dummy0.break])) }
	{% endif %}

[neopixel sb_leds]
pin = SB2240:PD3
chain_count = 3
color_order = GRBW
initial_red = 1.0
initial_green = 0.0
initial_blue = 1.0
initial_white = 0.0

[gcode_macro _sb_vars]
variable_colors = {
	'logo': {
	'busy': {'r': 0.4, 'g': 0.0, 'b': 0.0, 'w': 0.0},
	'cleaning': {'r': 0.0, 'g': 0.02, 'b': 0.5, 'w': 0.0},
	'calibrating_z': {'r': 0.8, 'g': 0., 'b': 0.35, 'w': 0.0},
	'heating': {'r': 0.3, 'g': 0.18, 'b': 0.0, 'w': 0.0},
	'homing': {'r': 0.0, 'g': 0.6, 'b': 0.2, 'w': 0.0},
	'leveling': {'r': 0.5, 'g': 0.1, 'b': 0.4, 'w': 0.0},
	'meshing': {'r': 0.2, 'g': 1.0, 'b': 0.0, 'w': 0.0},
	'off': {'r': 0.0, 'g': 0.0, 'b': 0.0, 'w': 0.0},
	'printing': {'r': 1.0, 'g': 0.0, 'b': 0.0, 'w': 0.0},
	'standby': {'r': 0.01, 'g': 0.01, 'b': 0.01, 'w': 0.1},
	},
	'nozzle': {
	'heating': {'r': 0.8, 'g': 0.35, 'b': 0.0, 'w':0.0},
	'off': {'r': 0.0, 'g': 0.0, 'b': 0.0, 'w': 0.0},
	'on': {'r': 0.8, 'g': 0.8, 'b': 0.8, 'w':1.0},
	'standby': {'r': 0.6, 'g': 0.0, 'b': 0.0, 'w':0.0},
	},
	'thermal': {
	'hot': {'r': 1.0, 'g': 0.0, 'b': 0.0, 'w': 0.0},
	'cold': {'r': 0.3, 'g': 0.0, 'b': 0.3, 'w': 0.0}
	}
	}
variable_logo_led_name = "sb_leds"
variable_logo_idx = "1"
variable_nozzle_led_name = "sb_leds"
variable_nozzle_idx = "2,3"
gcode = 

[gcode_macro _set_sb_leds]
gcode = 
	{% set red = params.RED|default(0)|float %}
	{% set green = params.GREEN|default(0)|float %}
	{% set blue = params.BLUE|default(0)|float %}
	{% set white = params.WHITE|default(0)|float %}
	{% set led = params.LED|string %}
	{% set idx = (params.IDX|string).split(',') %}
	{% set transmit_last = params.TRANSMIT|default(1) %}
	
	{% for led_index in idx %}
	{% set transmit=transmit_last if loop.last else 0 %}
	set_led led={led} red={red} green={green} blue={blue} white={white} index={led_index} transmit={transmit}
	{% endfor %}

[gcode_macro _set_sb_leds_by_name]
gcode = 
	{% set leds_name = params.LEDS %}
	{% set color_name = params.COLOR %}
	{% set color = printer["gcode_macro _sb_vars"].colors[leds_name][color_name] %}
	{% set led = printer["gcode_macro _sb_vars"][leds_name + "_led_name"] %}
	{% set idx = printer["gcode_macro _sb_vars"][leds_name + "_idx"] %}
	{% set transmit = params.TRANSMIT|default(1) %}
	
	_set_sb_leds led={led} red={color.r} green={color.g} blue={color.b} white={color.w} idx="{idx}" transmit={transmit}

[gcode_macro _set_logo_leds]
gcode = 
	{% set red = params.RED|default(0)|float %}
	{% set green = params.GREEN|default(0)|float %}
	{% set blue = params.BLUE|default(0)|float %}
	{% set white = params.WHITE|default(0)|float %}
	{% set led = printer["gcode_macro _sb_vars"].logo_led_name %}
	{% set idx = printer["gcode_macro _sb_vars"].logo_idx %}
	{% set transmit=params.TRANSMIT|default(1) %}
	
	_set_sb_leds led={led} red={red} green={green} blue={blue} white={white} idx="{idx}" transmit={transmit}

[gcode_macro _set_nozzle_leds]
gcode = 
	{% set red = params.RED|default(0)|float %}
	{% set green = params.GREEN|default(0)|float %}
	{% set blue = params.BLUE|default(0)|float %}
	{% set white = params.WHITE|default(0)|float %}
	{% set led = printer["gcode_macro _sb_vars"].nozzle_led_name %}
	{% set idx = printer["gcode_macro _sb_vars"].nozzle_idx %}
	{% set transmit=params.TRANSMIT|default(1) %}
	
	_set_sb_leds led={led} red={red} green={green} blue={blue} white={white} idx="{idx}" transmit={transmit}

[gcode_macro set_logo_leds_off]
gcode = 
	{% set transmit=params.TRANSMIT|default(1) %}
	_set_logo_leds red=0 blue=0 green=0 white=0 transmit={transmit}

[gcode_macro set_nozzle_leds_on]
gcode = 
	{% set transmit=params.TRANSMIT|default(1) %}
	_set_sb_leds_by_name leds="nozzle" color="on" transmit={transmit}

[gcode_macro set_nozzle_leds_off]
gcode = 
	{% set transmit=params.TRANSMIT|default(1) %}
	_set_sb_leds_by_name leds="nozzle" color="off" transmit={transmit}

[gcode_macro status_off]
gcode = 
	set_logo_leds_off transmit=0
	set_nozzle_leds_off

[gcode_macro status_ready]
gcode = 
	_set_sb_leds_by_name leds="logo" color="standby" transmit=0
	_set_sb_leds_by_name leds="nozzle" color="standby" transmit=1

[gcode_macro status_busy]
gcode = 
	_set_sb_leds_by_name leds="logo" color="busy" transmit=0
	set_nozzle_leds_on

[gcode_macro status_heating]
gcode = 
	_set_sb_leds_by_name leds="logo" color="heating" transmit=0
	_set_sb_leds_by_name leds="nozzle" color="heating" transmit=1

[gcode_macro status_leveling]
gcode = 
	_set_sb_leds_by_name leds="logo" color="leveling" transmit=0
	set_nozzle_leds_on

[gcode_macro status_homing]
gcode = 
	_set_sb_leds_by_name leds="logo" color="homing" transmit=0
	set_nozzle_leds_on

[gcode_macro status_cleaning]
gcode = 
	_set_sb_leds_by_name leds="logo" color="cleaning" transmit=0
	set_nozzle_leds_on

[gcode_macro status_meshing]
gcode = 
	_set_sb_leds_by_name leds="logo" color="meshing" transmit=0
	set_nozzle_leds_on

[gcode_macro status_calibrating_z]
gcode = 
	_set_sb_leds_by_name leds="logo" color="calibrating_z" transmit=0
	set_nozzle_leds_on

[gcode_macro status_printing]
gcode = 
	_set_sb_leds_by_name leds="logo" color="printing" transmit=0
	set_nozzle_leds_on

[gcode_macro NOZZLE_CLEAN]
variable_start_x = 175
variable_start_y = 347
variable_start_z = 9.68
variable_wipe_dist_y = 3
variable_wipe_qty = 5
variable_wipe_spd = 50
variable_raise_distance = 18
gcode = 
	
	{% set ACTUAL_TEMP = printer.extruder.temperature %}
	{% set TARGET_TEMP = printer.extruder.target %}
	{% set WIPE_TEMP = 200 %}
	{% set MIN_TEMP = 170 %}
	
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	
	G1 X{start_x - 30} Y{start_y} F6000
	
	{% if ACTUAL_TEMP < WIPE_TEMP %}
	M104 S{ WIPE_TEMP }
	G4 2500
	{% endif %}
	
	G90
	G1 Z{start_z} F1500
	G91
	G1 X60 F6000
	G1 X-60 F6000
	G1 X60 F6000
	G1 X-60 F6000
	G1 X60 F6000
	G1 X-60 F6000
	
	G90
	
	G1 Z{start_z} F1500
	G1 X{start_x} Y{start_y} F6000
	
	
	G91
	{% for wipes in range(1, (wipe_qty + 1)) %}
	
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X-2 Y-{wipe_dist_y} F{wipe_spd * 300}
	
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y-{wipe_dist_y} F{wipe_spd * 300}
	G1 X2 Y{wipe_dist_y} F{wipe_spd * 300}
	
	{% endfor %}
	
	G90
	G1 X{start_x - 60} Y{start_y} F6000
	G1 YY{start_y} F6000

[gcode_macro OFF]
gcode = 
	M84
	TURN_OFF_HEATERS
	M107

[gcode_macro PARKFRONT]
gcode = 
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	SAVE_GCODE_STATE NAME=PARKFRONT
	G90
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_minimum.y+5} Z{printer.toolhead.axis_maximum.z/2} F12000
	RESTORE_GCODE_STATE NAME=PARKFRONT

[gcode_macro PARKFRONTLOW]
gcode = 
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	SAVE_GCODE_STATE NAME=PARKFRONT
	G90
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_minimum.y+5} Z20 F12000
	RESTORE_GCODE_STATE NAME=PARKFRONT

[gcode_macro PARKREAR]
gcode = 
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	SAVE_GCODE_STATE NAME=PARKREAR
	G90
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_maximum.y-10} Z{printer.toolhead.axis_maximum.z/2} F12000
	RESTORE_GCODE_STATE NAME=PARKREAR

[gcode_macro PARKCENTER]
gcode = 
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	SAVE_GCODE_STATE NAME=PARKCENTER
	G90
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_maximum.y/2} Z{printer.toolhead.axis_maximum.z/2} F12000
	RESTORE_GCODE_STATE NAME=PARKCENTER

[gcode_macro PARKBED]
gcode = 
	{% if "xyz" not in printer.toolhead.homed_axes %}
	G28
	{% endif %}
	SAVE_GCODE_STATE NAME=PARKBED
	G90
	G0 X{printer.toolhead.axis_maximum.x/2} Y{printer.toolhead.axis_maximum.y/2} Z15 F12000
	RESTORE_GCODE_STATE NAME=PARKBED

[gcode_macro PRINT_END]
gcode = 
	M400
	G92 E0
	G1 E-10.0 F3600
	G91
	G0 Z1.00 X20.0 Y20.0 F20000
	TURN_OFF_HEATERS
	M107
	G1 Z2 F3000
	G90
	G0  X175 Y350 F3600
	BED_MESH_CLEAR

[gcode_macro PRINT_START]
gcode = 
	
	{% set target_bed = params.BED|int %}
	{% set target_extruder = params.EXTRUDER|int %}
	
	{% set x_wait = printer.toolhead.axis_maximum.x|float / 2 %}
	{% set y_wait = printer.toolhead.axis_maximum.y|float / 2 %}
	
	
	STATUS_HOMING
	M109 S150
	M190 S{target_bed}
	G28
	G90
	
	NOZZLE_CLEAN
	
	
	BED_MESH_CLEAR
	
	
	{% if params.BED|int > 90 %}
	SET_DISPLAY_TEXT MSG="Bed: {target_bed}c"
	STATUS_HEATING
	M106 S255
	
	
	
	
	G1 X{x_wait} Y{y_wait} Z15 F9000
	M190 S{target_bed}
	
	
	
	
	{% else %}
	SET_DISPLAY_TEXT MSG="Bed: {target_bed}c"
	STATUS_HEATING
	G1 X{x_wait} Y{y_wait} Z15 F9000
	M190 S{target_bed}
	SET_DISPLAY_TEXT MSG="Soak for 5min"
	G4 P300000
	{% endif %}
	
	
	SET_DISPLAY_TEXT MSG="Hotend: 150c"
	M109 S150
	
	
	SET_DISPLAY_TEXT MSG="QGL"
	STATUS_LEVELING
	quad_gantry_level
	G28 Z
	
	
	SET_DISPLAY_TEXT MSG="Bed mesh"
	STATUS_MESHING
	BED_MESH_CALIBRATE
	
	
	SET_DISPLAY_TEXT MSG="Hotend: {target_extruder}c"
	STATUS_HEATING
	G1 X{x_wait} Y{y_wait} Z15 F9000
	M107
	M109 S{target_extruder}
	
	
	SET_DISPLAY_TEXT MSG="printing..."
	STATUS_PRINTING
	NOZZLE_CLEAN
	LINE_PURGE

[gcode_macro SHUTDOWN]
gcode = 
	
	OFF
	{action_respond_info('action:poweroff')}
	{action_call_remote_method("shutdown_machine")}

[gcode_macro BED_MESH_CALIBRATE]
rename_existing = _BED_MESH_CALIBRATE
gcode = 
	
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set bed_mesh_min = printer.configfile.settings.bed_mesh.mesh_min %}
	{% set bed_mesh_max = printer.configfile.settings.bed_mesh.mesh_max %}
	{% set probe_count = printer.configfile.settings.bed_mesh.probe_count %}
	{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}
	{% set probe_dock_enable = printer["gcode_macro _KAMP_Settings"].probe_dock_enable | abs %}
	{% set attach_macro = printer["gcode_macro _KAMP_Settings"].attach_macro | string %}
	{% set detach_macro = printer["gcode_macro _KAMP_Settings"].detach_macro | string %}
	{% set mesh_margin = printer["gcode_macro _KAMP_Settings"].mesh_margin | float %}
	{% set fuzz_amount = printer["gcode_macro _KAMP_Settings"].fuzz_amount | float %}
	{% set probe_count = probe_count if probe_count|length > 1 else probe_count * 2  %}
	{% set max_probe_point_distance_x = ( bed_mesh_max[0] - bed_mesh_min[0] ) / (probe_count[0] - 1)  %}
	{% set max_probe_point_distance_y = ( bed_mesh_max[1] - bed_mesh_min[1] ) / (probe_count[1] - 1)  %}
	{% set x_min = all_points | map(attribute=0) | min | default(bed_mesh_min[0]) %}
	{% set y_min = all_points | map(attribute=1) | min | default(bed_mesh_min[1]) %}
	{% set x_max = all_points | map(attribute=0) | max | default(bed_mesh_max[0]) %}
	{% set y_max = all_points | map(attribute=1) | max | default(bed_mesh_max[1]) %}
	
	{% set fuzz_range = range((0) | int, (fuzz_amount * 100) | int + 1) %}
	{% set adapted_x_min = (bed_mesh_min[0] + fuzz_amount - mesh_margin, x_min) | max - (fuzz_range | random / 100.0) %}
	{% set adapted_y_min = (bed_mesh_min[1] + fuzz_amount - mesh_margin, y_min) | max - (fuzz_range | random / 100.0) %}
	{% set adapted_x_max = (bed_mesh_max[0] - fuzz_amount + mesh_margin, x_max) | min + (fuzz_range | random / 100.0) %}
	{% set adapted_y_max = (bed_mesh_max[1] - fuzz_amount + mesh_margin, y_max) | min + (fuzz_range | random / 100.0) %}
	
	{% set adapted_x_min = [adapted_x_min , bed_mesh_min[0]] | max %}
	{% set adapted_y_min = [adapted_y_min , bed_mesh_min[1]] | max %}
	{% set adapted_x_max = [adapted_x_max , bed_mesh_max[0]] | min %}
	{% set adapted_y_max = [adapted_y_max , bed_mesh_max[1]] | min %}
	
	{% set points_x = (((adapted_x_max - adapted_x_min) / max_probe_point_distance_x) | round(method='ceil') | int) + 1 %}
	{% set points_y = (((adapted_y_max - adapted_y_min) / max_probe_point_distance_y) | round(method='ceil') | int) + 1 %}
	
	{% if (([points_x, points_y]|max) > 6) %}
	{% set algorithm = "bicubic" %}
	{% set min_points = 4 %}
	{% else %}
	{% set algorithm = "lagrange" %}
	{% set min_points = 3 %}
	{% endif %}
	
	{% set points_x = [points_x , min_points]|max %}
	{% set points_y = [points_y , min_points]|max %}
	{% set points_x = [points_x , probe_count[0]]|min %}
	{% set points_y = [points_y , probe_count[1]]|min %}
	
	{% if verbose_enable == True %}
	
	{ action_respond_info( "Algorithm: {}.".format(
	(algorithm),
	)) }
	
	{ action_respond_info("Default probe count: {},{}.".format(
	(probe_count[0]),
	(probe_count[1]),
	)) }
	
	{ action_respond_info("Adapted probe count: {},{}.".format(
	(points_x),
	(points_y),
	)) }
	
	{action_respond_info("Default mesh bounds: {}, {}.".format(
	(bed_mesh_min[0],bed_mesh_min[1]),
	(bed_mesh_max[0],bed_mesh_max[1]),
	)) }
	
	{% if mesh_margin > 0 %}
	{action_respond_info("Mesh margin is {}, mesh bounds extended by {}mm.".format(
	(mesh_margin),
	(mesh_margin),
	)) }
	{% else %}
	{action_respond_info("Mesh margin is 0, margin not increased.")}
	{% endif %}
	
	{% if fuzz_amount > 0 %}
	{action_respond_info("Mesh point fuzzing enabled, points fuzzed up to {}mm.".format(
	(fuzz_amount),
	)) }
	{% else %}
	{action_respond_info("Fuzz amount is 0, mesh points not fuzzed.")}
	{% endif %}
	
	{ action_respond_info("Adapted mesh bounds: {}, {}.".format(
	(adapted_x_min, adapted_y_min),
	(adapted_x_max, adapted_y_max),
	)) }
	
	{action_respond_info("KAMP adjustments successful. Happy KAMPing!")}
	
	{% endif %}
	
	{% if probe_dock_enable == True %}
	{attach_macro}
	{% endif %}
	
	_BED_MESH_CALIBRATE mesh_min={adapted_x_min},{adapted_y_min} mesh_max={adapted_x_max},{adapted_y_max} ALGORITHM={algorithm} PROBE_COUNT={points_x},{points_y}
	
	{% if probe_dock_enable == True %}
	{detach_macro}
	{% endif %}

[gcode_macro _KAMP_Settings]
description = This macro contains all adjustable settings for KAMP
variable_verbose_enable = True
variable_mesh_margin = 0
variable_fuzz_amount = 0
variable_probe_dock_enable = False
variable_attach_macro = 'Attach_Probe'
variable_detach_macro = 'Dock_Probe'
variable_purge_height = 0.8
variable_tip_distance = 0
variable_purge_margin = 10
variable_purge_amount = 30
variable_flow_rate = 12
variable_smart_park_height = 10
gcode = 
	
	{action_respond_info(" Running the KAMP_Settings macro does nothing, it is only used for storing KAMP settings. ")}

[gcode_macro LINE_PURGE]
description = A purge macro that adapts to be near your actual printed objects
gcode = 
	
	{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}
	{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}
	
	
	{% if printer.firmware_retraction is defined %}
	{% set RETRACT = G10 | string %}
	{% set UNRETRACT = G11 | string %}
	{% else %}
	{% set RETRACT = 'G1 E-.5 F2100' | string %}
	{% set UNRETRACT = 'G1 E.5 F2100' | string %}
	{% endif %}
	
	
	{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}
	{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}
	{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}
	{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}
	{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}
	{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}
	
	
	
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}
	{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}
	{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}
	{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}
	
	{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}
	{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}
	
	{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}
	{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}
	
	
	{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}
	
	{% if cross_section < 5 %}
	
	{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}
	
	{% else %}
	
	{% if verbose_enable == True %}
	
	{action_respond_info("Moving filament tip {}mms".format(
	(tip_distance),
	)) }
	{% endif %}
	
	{% if printer.firmware_retraction is defined %}
	{action_respond_info("KAMP purge is using firmware retraction.")}
	{% else %}
	{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}
	{% endif %}
	
	{% if purge_y_origin > 0 %}
	
	{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(
	(purge_x_center),
	(purge_y_origin),
	(purge_amount),
	(flow_rate),
	)) }
	
	{% else %}
	
	{action_respond_info("KAMP purge starting at {}, {} and purging {}mm of filament, requested flow rate is {}mm/s3.".format(
	(purge_x_origin),
	(purge_y_center),
	(purge_amount),
	(flow_rate),
	)) }
	
	{% endif %}
	
	SAVE_GCODE_STATE NAME=Prepurge_State
	
	{% if purge_y_origin > 0 %}
	
	G92 E0
	G0 F{travel_speed}
	G90
	G0 X{purge_x_center} Y{purge_y_origin}
	G0 Z{purge_height}
	M83
	G1 E{tip_distance} F{purge_move_speed}
	G1 X{purge_x_center + purge_amount} E{purge_amount} F{purge_move_speed}
	{RETRACT}
	G0 X{purge_x_center + purge_amount + 10} F{travel_speed}
	G92 E0
	M82
	G0 Z{purge_height * 2} F{travel_speed}
	
	{% else %}
	
	G92 E0
	G0 F{travel_speed}
	G90
	G0 X{purge_x_origin} Y{purge_y_center}
	G0 Z{purge_height}
	M83
	G1 E{tip_distance} F{purge_move_speed}
	G1 Y{purge_y_center + purge_amount} E{purge_amount} F{purge_move_speed}
	{RETRACT}
	G0 Y{purge_y_center + purge_amount + 10} F{travel_speed}
	G92 E0
	M82
	G0 Z{purge_height * 2} F{travel_speed}
	
	{% endif %}
	
	RESTORE_GCODE_STATE NAME=Prepurge_State
	
	{% endif %}

[gcode_macro SMART_PARK]
description = Parks your printhead near the print area for pre-print hotend heating.
gcode = 
	
	{% set kamp_settings = printer["gcode_macro _KAMP_Settings"] %}
	{% set z_height = kamp_settings.smart_park_height | float %}
	{% set purge_margin = kamp_settings.purge_margin | float %}
	{% set verbose_enable = kamp_settings.verbose_enable | abs %}
	{% set center_x = printer.toolhead.axis_maximum.x / 2 | float %}
	{% set center_y = printer.toolhead.axis_maximum.y / 2 | float %}
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set x_min = all_points | map(attribute=0) | min | default(center_x) %}
	{% set y_min = all_points | map(attribute=1) | min | default(center_y) %}
	{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}
	
	{% if purge_margin > 0 and x_min != center_x and y_min != center_y %}
	{% set x_min = [ x_min - purge_margin , x_min ] | max %}
	{% set y_min = [ y_min - purge_margin , y_min ] | max %}
	{% endif %}
	
	
	{% if verbose_enable == True %}
	
	{ action_respond_info("Smart Park location: {},{}.".format(
	(x_min),
	(y_min),
	)) }
	
	{% endif %}
	
	G0 X{x_min} Y{y_min} F{travel_speed}
	G0 Z{z_height}

[gcode_macro VORON_PURGE]
description = A purge macro that adapts to be near your actual printed objects
gcode = 
	
	{% set travel_speed = (printer.toolhead.max_velocity) * 60 | float %}
	{% set cross_section = printer.configfile.settings.extruder.max_extrude_cross_section | float %}
	
	
	{% if printer.firmware_retraction is defined %}
	{% set RETRACT = G10 | string %}
	{% set UNRETRACT = G11 | string %}
	{% else %}
	{% set RETRACT = 'G1 E-.5 F2100' | string %}
	{% set UNRETRACT = 'G1 E.5 F2100' | string %}
	{% endif %}
	
	
	{% set verbose_enable = printer["gcode_macro _KAMP_Settings"].verbose_enable | abs %}
	{% set purge_height = printer["gcode_macro _KAMP_Settings"].purge_height | float %}
	{% set tip_distance = printer["gcode_macro _KAMP_Settings"].tip_distance | float %}
	{% set purge_margin = printer["gcode_macro _KAMP_Settings"].purge_margin | float %}
	{% set purge_amount = printer["gcode_macro _KAMP_Settings"].purge_amount | float %}
	{% set flow_rate = printer["gcode_macro _KAMP_Settings"].flow_rate | float %}
	{% set size = 10 | float %}
	
	
	{% set all_points = printer.exclude_object.objects | map(attribute='polygon') | sum(start=[]) %}
	{% set purge_x_min = (all_points | map(attribute=0) | min | default(0)) %}
	{% set purge_x_max = (all_points | map(attribute=0) | max | default(0)) %}
	{% set purge_y_min = (all_points | map(attribute=1) | min | default(0)) %}
	{% set purge_y_max = (all_points | map(attribute=1) | max | default(0)) %}
	
	{% set purge_x_center = ([((purge_x_max + purge_x_min) / 2) - (purge_amount / 2), 0] | max) %}
	{% set purge_y_center = ([((purge_y_max + purge_y_min) / 2) - (purge_amount / 2), 0] | max) %}
	
	{% set purge_x_origin = ([purge_x_min - purge_margin, 0] | max) %}
	{% set purge_y_origin = ([purge_y_min - purge_margin, 0] | max) %}
	
	
	{% set purge_move_speed = (flow_rate / 5.0) * 60 | float %}
	
	{% if cross_section < 5 %}
	
	{action_respond_info("[Extruder] max_extrude_cross_section is insufficient for purge, please set it to 5 or greater. Purge skipped.")}
	
	{% else %}
	
	{% if verbose_enable == True %}
	
	{action_respond_info("Moving filament tip {}mms".format(
	(tip_distance),
	)) }
	{% endif %}
	
	{% if printer.firmware_retraction is defined %}
	{action_respond_info("KAMP purge is using firmware retraction.")}
	{% else %}
	{action_respond_info("KAMP purge is not using firmware retraction, it is recommended to configure it.")}
	{% endif %}
	
	SAVE_GCODE_STATE NAME=Prepurge_State
	
	G92 E0
	G0 F{travel_speed}
	G90
	G0 X{purge_x_origin} Y{purge_y_origin+size/2}
	G0 Z{purge_height}
	M83
	G1 E{tip_distance} F{purge_move_speed}
	G1 X{purge_x_origin+size*0.289} Y{purge_y_origin+size} E{purge_amount/4} F{purge_move_speed}
	G1 E-.5 F2100
	G0 Z{purge_height*2}
	G0 X{purge_x_origin+size*0.789} Y{purge_y_origin+size}
	G0 Z{purge_height}
	G1 E.5 F2100
	G1 X{purge_x_origin+size*0.211} Y{purge_y_origin} E{purge_amount/2} F{purge_move_speed}
	G1 E-.5 F2100
	G0 Z{purge_height*2}
	G0 X{purge_x_origin+size*0.711} Y{purge_y_origin}
	G0 Z{purge_height}
	G1 E.5 F2100
	G1 X{purge_x_origin+size} Y{purge_y_origin+size/2}  E{purge_amount/4} F{purge_move_speed}
	G1 E-.5 F2100
	G92 E0
	M82
	G0 Z{purge_height*2} F{travel_speed}
	
	RESTORE_GCODE_STATE NAME=Prepurge_State
	
	{% endif %}

[exclude_object]

[printer]
kinematics = corexy
max_velocity = 300
max_accel = 3000
max_z_velocity = 15
max_z_accel = 350
square_corner_velocity = 5.0

[idle_timeout]
timeout = 1800

[extruder]
step_pin = SB2240: PD0
dir_pin = SB2240: PD1
enable_pin = !SB2240: PD2
rotation_distance = 21.6357193494
gear_ratio = 50:10
microsteps = 16
full_steps_per_rotation = 200
nozzle_diameter = 0.400
filament_diameter = 1.750
heater_pin = SB2240: PB13
sensor_type = EPCOS 100K B57560G104F
sensor_pin = SB2240: PA3
min_temp = 0
max_temp = 280
min_extrude_temp = 190
control = pid
pid_kp = 31.337
pid_ki = 3.798
pid_kd = 64.635

[tmc2240 extruder]
cs_pin = SB2240: PA15
spi_software_sclk_pin = SB2240: PB10
spi_software_mosi_pin = SB2240: PB11
spi_software_miso_pin = SB2240: PB2
driver_tpfd = 0
run_current = 0.4
stealthchop_threshold = 0

[heater_bed]
heater_pin = PB7
sensor_type = Generic 3950
sensor_pin = PA0
max_power = 1
min_temp = 0
max_temp = 120
control = pid
pid_kp = 57.515
pid_ki = 2.719
pid_kd = 304.113

[probe]
activate_gcode = 
	{% set PROBE_TEMP = 150 %}
	{% set MAX_TEMP = PROBE_TEMP + 5 %}
	{% set ACTUAL_TEMP = printer.extruder.temperature %}
	{% set TARGET_TEMP = printer.extruder.target %}
	
	{% if TARGET_TEMP > PROBE_TEMP %}
	{ action_respond_info('Extruder temperature target of %.1fC is too high, lowering to %.1fC' % (TARGET_TEMP, PROBE_TEMP)) }
	M109 S{ PROBE_TEMP }
	{% else %}
	
	{% if ACTUAL_TEMP > MAX_TEMP %}
	{ action_respond_info('Extruder temperature %.1fC is still too high, waiting until below %.1fC' % (ACTUAL_TEMP, MAX_TEMP)) }
	TEMPERATURE_WAIT SENSOR=extruder MAXIMUM={ MAX_TEMP }
	{% endif %}
	{% endif %}
pin = !SB2240: PC13
x_offset = 0
y_offset = 0
speed = 20
samples = 3
samples_result = median
sample_retract_dist = 1.0
samples_tolerance = 0.006
samples_tolerance_retries = 20
lift_speed = 200
z_offset = -0.875

[bed_mesh default]
version = 1
points = 
	-0.007547, -0.008172, -0.023328
	-0.003016, 0.006672, -0.006766
	0.002922, -0.011297, 0.000266
x_count = 3
y_count = 3
mesh_x_pps = 2
mesh_y_pps = 2
algo = lagrange
tension = 0.2
min_x = 148.04
max_x = 202.1
min_y = 107.62
max_y = 193.22
=======================
Extruder max_extrude_ratio=0.266081
mcu 'mcu': Starting serial connect
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
webhooks client 548425231184: New connection
webhooks client 548425231184: Client info {'program': 'Moonraker', 'version': 'v0.8.0-286-gf44fc4b'}
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
mcu 'mcu': Unable to open serial port: [Errno 2] could not open port /dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00: [Errno 2] No such file or directory: '/dev/serial/by-id/usb-Klipper_stm32g0b1xx_0E001A000D504B4633373520-if00'
MCU error during connect
Traceback (most recent call last):
  File "/home/pi/klipper/klippy/mcu.py", line 768, in _mcu_identify
    self._serial.connect_uart(self._serialport, self._baud, rts)
  File "/home/pi/klipper/klippy/serialhdl.py", line 182, in connect_uart
    self._error("Unable to connect")
  File "/home/pi/klipper/klippy/serialhdl.py", line 61, in _error
    raise error(self.warn_prefix + (msg % params))
serialhdl.error: mcu 'mcu': Unable to connect

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/home/pi/klipper/klippy/klippy.py", line 176, in _connect
    self.send_event("klippy:mcu_identify")
  File "/home/pi/klipper/klippy/klippy.py", line 263, in send_event
    return [cb(*params) for cb in self.event_handlers.get(event, [])]
  File "/home/pi/klipper/klippy/klippy.py", line 263, in <listcomp>
    return [cb(*params) for cb in self.event_handlers.get(event, [])]
  File "/home/pi/klipper/klippy/mcu.py", line 773, in _mcu_identify
    raise error(str(e))
mcu.error: mcu 'mcu': Unable to connect
Build file /home/pi/klipper/klippy/../.config(3445): Fri Jan 26 22:28:46 2024
========= Last MCU build config =========
CONFIG_LOW_LEVEL_OPTIONS=y
# CONFIG_MACH_AVR is not set
# CONFIG_MACH_ATSAM is not set
# CONFIG_MACH_ATSAMD is not set
# CONFIG_MACH_LPC176X is not set
CONFIG_MACH_STM32=y
# CONFIG_MACH_HC32F460 is not set
# CONFIG_MACH_RP2040 is not set
# CONFIG_MACH_PRU is not set
# CONFIG_MACH_AR100 is not set
# CONFIG_MACH_LINUX is not set
# CONFIG_MACH_SIMU is not set
CONFIG_BOARD_DIRECTORY="stm32"
CONFIG_MCU="stm32g0b1xx"
CONFIG_CLOCK_FREQ=64000000
CONFIG_USBSERIAL=y
CONFIG_FLASH_SIZE=0x20000
CONFIG_FLASH_BOOT_ADDRESS=0x8000000
CONFIG_RAM_START=0x20000000
CONFIG_RAM_SIZE=0x24000
CONFIG_STACK_SIZE=512
CONFIG_FLASH_APPLICATION_ADDRESS=0x8002000
CONFIG_STM32_SELECT=y
# CONFIG_MACH_STM32F103 is not set
# CONFIG_MACH_STM32F207 is not set
# CONFIG_MACH_STM32F401 is not set
# CONFIG_MACH_STM32F405 is not set
# CONFIG_MACH_STM32F407 is not set
# CONFIG_MACH_STM32F429 is not set
# CONFIG_MACH_STM32F446 is not set
# CONFIG_MACH_STM32F765 is not set
# CONFIG_MACH_STM32F031 is not set
# CONFIG_MACH_STM32F042 is not set
# CONFIG_MACH_STM32F070 is not set
# CONFIG_MACH_STM32F072 is not set
# CONFIG_MACH_STM32G070 is not set
# CONFIG_MACH_STM32G071 is not set
# CONFIG_MACH_STM32G0B0 is not set
CONFIG_MACH_STM32G0B1=y
# CONFIG_MACH_STM32G431 is not set
# CONFIG_MACH_STM32H723 is not set
# CONFIG_MACH_STM32H743 is not set
# CONFIG_MACH_STM32H750 is not set
# CONFIG_MACH_STM32L412 is not set
# CONFIG_MACH_N32G452 is not set
# CONFIG_MACH_N32G455 is not set
CONFIG_MACH_STM32G0=y
CONFIG_MACH_STM32G0Bx=y
CONFIG_HAVE_STM32_USBFS=y
CONFIG_HAVE_STM32_FDCANBUS=y
CONFIG_HAVE_STM32_USBCANBUS=y
CONFIG_STM32_DFU_ROM_ADDRESS=0x1fff0000
CONFIG_STM32_FLASH_START_2000=y
# CONFIG_STM32_FLASH_START_0000 is not set
CONFIG_STM32_CLOCK_REF_8M=y
# CONFIG_STM32_CLOCK_REF_12M is not set
# CONFIG_STM32_CLOCK_REF_16M is not set
# CONFIG_STM32_CLOCK_REF_20M is not set
# CONFIG_STM32_CLOCK_REF_24M is not set
# CONFIG_STM32_CLOCK_REF_25M is not set
# CONFIG_STM32_CLOCK_REF_INTERNAL is not set
CONFIG_CLOCK_REF_FREQ=8000000
CONFIG_STM32F0_TRIM=16
CONFIG_STM32_USB_PA11_PA12=y
# CONFIG_STM32_SERIAL_USART1 is not set
# CONFIG_STM32_SERIAL_USART1_ALT_PB7_PB6 is not set
# CONFIG_STM32_SERIAL_USART2 is not set
# CONFIG_STM32_SERIAL_USART2_ALT_PD6_PD5 is not set
# CONFIG_STM32_SERIAL_USART3 is not set
# CONFIG_STM32_SERIAL_USART3_ALT_PD9_PD8 is not set
# CONFIG_STM32_SERIAL_USART5 is not set
# CONFIG_STM32_CANBUS_PA11_PA12 is not set
# CONFIG_STM32_CANBUS_PA11_PB9 is not set
# CONFIG_STM32_MMENU_CANBUS_PB8_PB9 is not set
# CONFIG_STM32_MMENU_CANBUS_PB12_PB13 is not set
# CONFIG_STM32_MMENU_CANBUS_PD0_PD1 is not set
# CONFIG_STM32_MMENU_CANBUS_PB0_PB1 is not set
# CONFIG_STM32_MMENU_CANBUS_PD12_PD13 is not set
# CONFIG_STM32_MMENU_CANBUS_PC2_PC3 is not set
# CONFIG_STM32_USBCANBUS_PA11_PA12 is not set
CONFIG_USB=y
CONFIG_USB_VENDOR_ID=0x1d50
CONFIG_USB_DEVICE_ID=0x614e
CONFIG_USB_SERIAL_NUMBER_CHIPID=y
CONFIG_USB_SERIAL_NUMBER="12345"

#
# USB ids
#
# end of USB ids

CONFIG_WANT_GPIO_BITBANGING=y
CONFIG_WANT_DISPLAYS=y
CONFIG_WANT_SENSORS=y
CONFIG_WANT_LIS2DW=y
CONFIG_WANT_SOFTWARE_I2C=y
CONFIG_WANT_SOFTWARE_SPI=y
CONFIG_NEED_SENSOR_BULK=y
CONFIG_CANBUS_FREQUENCY=1000000
CONFIG_INITIAL_PINS=""
CONFIG_HAVE_GPIO=y
CONFIG_HAVE_GPIO_ADC=y
CONFIG_HAVE_GPIO_SPI=y
CONFIG_HAVE_GPIO_I2C=y
CONFIG_HAVE_GPIO_HARD_PWM=y
CONFIG_HAVE_STRICT_TIMING=y
CONFIG_HAVE_CHIPID=y
CONFIG_HAVE_STEPPER_BOTH_EDGE=y
CONFIG_HAVE_BOOTLOADER_REQUEST=y
CONFIG_INLINE_STEPPER_HACK=y
=======================
Build file /home/pi/klipper/klippy/../out/klipper.dict(7720): Fri Jan 26 22:29:04 2024
Last MCU build version: v0.12.0-98-g5e433fff
Last MCU build tools: gcc: (15:8-2019-q3-1+b1) 8.3.1 20190703 (release) [gcc-8-branch revision 273027] binutils: (2.35.2-2+14+b2) 2.35.2
Last MCU build config: ADC_MAX=4095 BUS_PINS_i2c1_PA9_PA10=PA9,PA10 BUS_PINS_i2c1_PB6_PB7=PB6,PB7 BUS_PINS_i2c1_PB8_PB9=PB8,PB9 BUS_PINS_i2c2_PB10_PB11=PB10,PB11 BUS_PINS_i2c2_PB13_PB14=PB13,PB14 BUS_PINS_i2c3_PB3_PB4=PB3,PB4 BUS_PINS_spi1=PA6,PA7,PA5 BUS_PINS_spi1a=PB4,PB5,PB3 BUS_PINS_spi2=PB14,PB15,PB13 BUS_PINS_spi2a=PC2,PC3,PB10 BUS_PINS_spi3=PB4,PB5,PB3 CLOCK_FREQ=64000000 MCU=stm32g0b1xx PWM_MAX=255 RESERVE_PINS_USB=PA11,PA12 RESERVE_PINS_crystal=PF0,PF1 STATS_SUMSQ_BASE=256 STEPPER_BOTH_EDGE=1
Build file /home/pi/klipper/klippy/../out/klipper.elf(1057236): Fri Jan 26 22:29:11 2024
